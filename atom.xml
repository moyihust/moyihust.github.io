<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://moyihust.github.io</id>
    <title>moyihust的小站</title>
    <updated>2024-02-27T03:07:46.665Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://moyihust.github.io"/>
    <link rel="self" href="https://moyihust.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://moyihust.github.io/images/avatar.png</logo>
    <icon>https://moyihust.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, moyihust的小站</rights>
    <entry>
        <title type="html"><![CDATA[软安课设faq]]></title>
        <id>https://moyihust.github.io/post/ruan-an-ke-she-faq/</id>
        <link href="https://moyihust.github.io/post/ruan-an-ke-she-faq/">
        </link>
        <updated>2024-02-27T03:06:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="fqa">FQA</h3>
<p>dll注入后无法成功hook messagebox<br>
未在dllattach中break</p>
<pre><code class="language-C++">BOOL WINAPI DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        DisableThreadLibraryCalls(hModule);
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&amp;(PVOID&amp;)OldMessageBoxA, NewMessageBoxA);
        DetourAttach(&amp;(PVOID&amp;)OldMessageBoxW, NewMessageBoxW);
        DetourTransactionCommit();
        break;&lt;-here
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourDetach(&amp;(PVOID&amp;)OldMessageBoxA, NewMessageBoxA);
        DetourDetach(&amp;(PVOID&amp;)OldMessageBoxW, NewMessageBoxW);
        DetourTransactionCommit();
        break;
    }
    return TRUE;
}

</code></pre>
<hr>
<p><strong>commit message格式</strong></p>
<pre><code class="language-text">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
</code></pre>
<p><strong>type(必须)</strong></p>
<p>用于说明git commit的类别，只允许使用下面的标识。</p>
<p>feat：新功能（feature）。</p>
<p>fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。</p>
<ul>
<li>fix：产生diff并自动修复此问题。适合于一次提交直接修复问题</li>
<li>to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</li>
</ul>
<p>docs：文档（documentation）。</p>
<p>style：格式（不影响代码运行的变动）。</p>
<p>refactor：重构（即不是新增功能，也不是修改bug的代码变动）。</p>
<p>perf：优化相关，比如提升性能、体验。</p>
<p>test：增加测试。</p>
<p>chore：构建过程或辅助工具的变动。</p>
<p>revert：回滚到上一个版本。</p>
<p>merge：代码合并。</p>
<p>sync：同步主线或分支的Bug。</p>
<p><strong>scope(可选)</strong></p>
<p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p>
<p>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。</p>
<p><strong>subject(必须)</strong></p>
<p>subject是commit目的的简短描述，<strong>不超过50个字符</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统复习]]></title>
        <id>https://moyihust.github.io/post/cao-zuo-xi-tong-fu-xi/</id>
        <link href="https://moyihust.github.io/post/cao-zuo-xi-tong-fu-xi/">
        </link>
        <updated>2024-01-01T14:05:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="操作系统的定义">操作系统的定义</h2>
<ul>
<li>操作系统是一个大型系统程序
<ul>
<li>操作系统是一个大型的程序系统，它负责计算机系统<em>软件/硬件资源的分配</em>；控制和协调并发活动；<em>提供用户接口</em>，使用户获得良好的工作环境。</li>
</ul>
</li>
<li>管理并调度资源；</li>
<li>为用户提供接口。</li>
</ul>
<h3 id="操作系统的特性">操作系统的特性</h3>
<ul>
<li>并发性
<ul>
<li>同时处理多个任务的能力</li>
</ul>
</li>
<li>共享性
<ul>
<li>为多个并发任务提供资源共享</li>
</ul>
</li>
<li>不确定性
<ul>
<li>具有处理随机事件的能力
<ul>
<li>中断处理的能力</li>
<li>自动化能力</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="操作系统的功能">操作系统的功能</h2>
<h3 id="进程管理">进程管理</h3>
<ul>
<li>处理机分配</li>
<li>处理机管理</li>
<li>CPU管理</li>
<li>具体功能
<ul>
<li>进程控制：创建，暂停，唤醒，撤销</li>
<li>进程调度：调度策略，优先级</li>
<li>进程通信：进程间通信</li>
</ul>
</li>
</ul>
<h3 id="存储管理内存管理">存储管理/内存管理</h3>
<ul>
<li>为应用程序运行分配和管理所需的内存</li>
<li>支持多道程序设计</li>
<li>具体功能
<ul>
<li>内存分配</li>
<li>内存共享</li>
<li>内存保护</li>
<li>内存扩充</li>
<li>虚拟内存</li>
</ul>
</li>
</ul>
<h3 id="设备管理">设备管理</h3>
<ul>
<li>设备的分配和回收</li>
<li>设备的驱动机制/传输控制</li>
<li>为应用提供统一接口访问设备
<ul>
<li>设备无关性</li>
</ul>
</li>
<li>高效存取/设备缓冲机制</li>
</ul>
<h3 id="文件管理文件系统">文件管理文件系统</h3>
<ul>
<li>为用户提供统一的文件存取接口，高效组织存储空间，提高存取效率，实现信息共享和存取控制。</li>
<li>文件用户接口</li>
<li>存储空间管理</li>
<li>文件的操作</li>
<li>目录的操作</li>
<li>存取权限管理</li>
</ul>
<h2 id="操作系统的性能评价指标">操作系统的性能/评价指标</h2>
<ul>
<li>吞吐率
<ul>
<li>在单位时间内处理信息的能力。</li>
</ul>
</li>
<li>资源利用率
<ul>
<li>设备(CPU)使用的频度</li>
</ul>
</li>
<li>响应能力
<ul>
<li>从接收数据到输出结果的时间间隔。</li>
</ul>
</li>
<li>可移植性
<ul>
<li>改变硬件环境仍能正常工作的能力</li>
</ul>
</li>
<li>可靠性
<ul>
<li>发现、诊断和恢复系统故障的能力。</li>
</ul>
</li>
</ul>
<h2 id="操作系统的发展和演变">操作系统的发展和演变</h2>
<h3 id="手工操作无操作系统40年代-50年代初">手工操作(无操作系统)（40年代-50年代初）</h3>
<ul>
<li>结构特点
<ul>
<li>硬件：电子管、接线面板</li>
<li>程序：二进制（ 卡片/纸带，打孔）</li>
</ul>
</li>
<li>使用特点
<ul>
<li>上机：编程（打孔），预约，操作机器（开关/接线）</li>
<li>程序启动与结束：手工处理</li>
</ul>
</li>
<li>缺点
<ul>
<li>效率低：CPU利用率低</li>
<li>用户独占</li>
<li>缺少交互</li>
</ul>
</li>
</ul>
<h3 id="单道批处理系统-50年代">单道批处理系统（ 50年代）</h3>
<ul>
<li>工作过程
<ul>
<li>管理员将多个作业输入到磁盘形成作业队列；</li>
<li>监控程序（操作系统）依次自动处理磁盘中每个作业
<ul>
<li>装入—运行—撤出—装入—运行—撤出…….</li>
</ul>
</li>
<li>运行完毕，通知用户取结果</li>
</ul>
</li>
<li>工作特点
<ul>
<li>一批：作业队列</li>
<li>自动：识别作业</li>
<li>单道：串行</li>
</ul>
</li>
<li>实现
<ul>
<li>联机批处理
<ul>
<li>特点：主机负责运算，同时控制输入/输出</li>
<li>缺点：系统效率低</li>
</ul>
</li>
<li>脱机批处理
<ul>
<li>特点：主机负责运算；卫星机负责输入/输出。</li>
<li>优点：系统效率高</li>
<li>缺点：调度不灵活；保护问题</li>
</ul>
</li>
</ul>
</li>
<li>CPU
<ul>
<li>现象： 外设工作时CPU空闲， CPU工作时外设空闲。</li>
<li>结论：CPU和外设效率低。</li>
</ul>
</li>
</ul>
<h3 id="多道批处理系统60年代初">多道批处理系统（60年代初）</h3>
<ul>
<li>多道程序设计技术
<ul>
<li>内存中存放多道程序,当某道程序因为某种原因（例如请求I/O时）不能继续运行时，监控程序/OS便调度另一道程序投入运行，这样使CPU尽量处于忙碌状态，提高系统效率。</li>
</ul>
</li>
<li>多道批处理系统
<ul>
<li>采用多道程序设计技术实现的处理系统称为多道批处理系统。</li>
</ul>
</li>
<li>目的：
<ul>
<li>提高资源的利用率（或吞吐量）</li>
<li>CPU与外设并行</li>
<li>外设之间也并行</li>
</ul>
</li>
<li>实现资源共享
<ul>
<li>时分：分成多个时段：不同进程错开时段使用。</li>
<li>空分：分成多个单元：不同进程使用不同单元。</li>
</ul>
</li>
<li>多个程序同时在计算机/虚拟机上运行</li>
<li>特点：
<ul>
<li>多道
<ul>
<li>内存同时存放多道程序</li>
</ul>
</li>
<li>并行
<ul>
<li>宏观上</li>
</ul>
</li>
<li>串行
<ul>
<li>微观上</li>
</ul>
</li>
</ul>
</li>
<li>缺点
<ul>
<li>作业处理时间长</li>
<li>运行过程不确定</li>
<li>交互能力差</li>
</ul>
</li>
</ul>
<h3 id="分时操作系统60年代中-至今">分时操作系统（60年代中-至今）</h3>
<h4 id="技术前置">技术前置</h4>
<ul>
<li>中断技术
<ul>
<li>CPU收到外部信号（中断信号）后，转去处理外部事件，处理完毕后回到中断处（断点）继续原来工作。</li>
</ul>
</li>
<li>通道技术
<ul>
<li>专门处理外设与内存之间数据传输的处理机</li>
</ul>
</li>
</ul>
<h4 id="背景">背景</h4>
<ul>
<li>事务性任务和程序的涌现
<ul>
<li>交互性高</li>
<li>响应快速</li>
<li>多任务/多用户</li>
</ul>
</li>
<li>硬件
<ul>
<li>中断技术</li>
<li>大规模集成电路</li>
<li>多终端计算机
<ul>
<li>用户通过终端连接主机，通过终端与主机交互。</li>
<li>主机采用分时技术轮流为每个终端服务。</li>
</ul>
</li>
</ul>
</li>
<li>分时技术概念
<ul>
<li>主机以很短的“时间片”为单位，把CPU轮流地分配给每个作业（终端/用户）使用，直到全部作业被运行完</li>
<li>时间片：较短时间间隔</li>
<li>循环/轮流：响应及时
<ul>
<li>独占主机</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>多路调制性
<ul>
<li>多用户联机使用同一台计算机</li>
</ul>
</li>
<li>独占性
<ul>
<li>用户感觉独占计算机</li>
</ul>
</li>
<li>交互性
<ul>
<li>及时响应用户的请求</li>
</ul>
</li>
</ul>
<h4 id="分时操作系统演化">分时操作系统演化</h4>
<ul>
<li>实时操作系统
<ul>
<li>实时要求
<ul>
<li>实时事务：军用电子、工业控制，智能仪器等</li>
<li>某些任务要优先紧急地处理
<ul>
<li>强调作业完成的时限(dead-line)</li>
<li>完成时间的可预测性</li>
</ul>
</li>
</ul>
</li>
<li>分类
<ul>
<li>硬实时系统
<ul>
<li>火炮控制系统</li>
<li>航空航天</li>
<li>工业控制</li>
</ul>
</li>
<li>软实时系统
<ul>
<li>尽可能快完成</li>
<li>网络视频</li>
<li>广播</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>微机操作系统（PC机操作系统）</li>
<li>多处理机操作系统
<ul>
<li>包含两个或多个功能相当的处理器（CPU）</li>
<li>共享：内存，I/O通道、外设</li>
<li>单一操作系统控制</li>
<li>特点
<ul>
<li>具有一定的并行处理能力</li>
<li>Linux支持SMP</li>
</ul>
</li>
</ul>
</li>
<li>网络操作系统
<ul>
<li>计算机网络：通过协议将多台计算机互连实现资源共享和信息传递的计算机系统。</li>
<li>网络操作系统=普通操作系统+网络通信+网络服务</li>
<li>特点：
<ul>
<li>主机独立自治</li>
<li>通信协议</li>
<li>IP/端口的标识</li>
</ul>
</li>
</ul>
</li>
<li>分布式操作系统
<ul>
<li>通过网络将多个通用资源部件互联，并能对资源进行全局统一管理和调度的计算机系统。</li>
<li>特点：
<ul>
<li>可运行分布式程序</li>
<li>主机自治又相互协调</li>
<li>可扩展性| 高可靠性</li>
</ul>
</li>
<li>与计算机网络的区别
<ul>
<li>支持单点登录（虚拟为“单台”计算机）</li>
<li>支持资源透明存取（计算机网络：通过IP指明主机）</li>
<li>支持合作运算（计算机网络：不支持）</li>
</ul>
</li>
</ul>
</li>
<li>嵌入式操作系统
<ul>
<li>嵌入式系统使用的操作系统</li>
<li>实时操作系统∈ 嵌入式操作系统</li>
</ul>
</li>
</ul>
<h2 id="操作系统的逻辑结构">操作系统的逻辑结构</h2>
<ul>
<li>OS的设计和实现思路</li>
</ul>
<h3 id="整体式结构单体式结构宏内核结构">整体式结构(单体式结构，宏内核结构)</h3>
<ul>
<li>以模块为基本单位构建
<ul>
<li>每个模块具有特定的功能</li>
</ul>
</li>
<li>定义
<ul>
<li>模块化结构/单体内核结构/宏内核结构</li>
<li>操作系统由大量过程构成。每个过程都有明确参数列表、返回值类型。大多数过程是可以相互间调用。</li>
</ul>
</li>
<li>优点：
<ul>
<li>模块的设计、编码和调试独立。</li>
<li>模块之间可以自由调用。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>错误容易扩散</li>
<li>开发和维护困难</li>
<li>可伸缩性差</li>
</ul>
</li>
</ul>
<h3 id="层次式结构">层次式结构</h3>
<ul>
<li>定义
<ul>
<li>功能模块按调用次序排若干层，各层单向依赖或单向调用</li>
</ul>
</li>
<li>分层原则
<ul>
<li>最底层：硬件相关</li>
<li>最顶层：用户策略/用户交互</li>
<li>中间层：按调用次序/消息传递顺序</li>
<li>较低层：共性的、活跃的服务</li>
</ul>
</li>
<li>优点：
<ul>
<li>结构清晰，避免循环调用。</li>
<li>整体问题局部化，系统的正确性容易保证。</li>
<li>有利于操作系统的移植、维护、扩充。</li>
</ul>
</li>
</ul>
<h3 id="微内核结构">微内核结构</h3>
<ul>
<li>操作系统= 微内核+ 核外服务器</li>
<li>客户：应用程序</li>
<li>服务器：操作系统=微内核+核外服务器</li>
<li>微内核
<ul>
<li>足够小，提供OS最基本的核心功能和服务
<ul>
<li>实现与硬件紧密相关的处理</li>
<li>实现一些较基本的功能；</li>
<li>负责客户和服务器间的通信。</li>
</ul>
</li>
</ul>
</li>
<li>核外服务器
<ul>
<li>完成OS绝大部分功能，等待客户提出请求。</li>
<li>由若干服务器或进程共同构成
<ul>
<li>例如：进程/线程服务器，虚存服务器，设备管理服务器等，以进程形式运行在用户态。</li>
</ul>
</li>
</ul>
</li>
<li>微内核和单体内核（宏内核）比较<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231230055332.png" alt="" loading="lazy"></li>
<li></li>
</ul>
<h3 id="cpu的态">CPU的态</h3>
<ul>
<li>CPU的工作模式</li>
<li>对资源和指令使用权限的描述</li>
<li>用户态
<ul>
<li>有限的指令</li>
</ul>
</li>
<li>核态
<ul>
<li>全部指令</li>
</ul>
</li>
</ul>
<h4 id="特权指令">特权指令</h4>
<ul>
<li>类别
<ul>
<li>涉及外部设备的输入/输出指令</li>
<li>修改特殊寄存器的指令</li>
<li>改变机器状态的指令</li>
</ul>
</li>
<li>例子
<ul>
<li>LGDT/LIDT/CLTS：装载特殊寄存器</li>
<li>STI/CTI：允许和禁止中断</li>
<li>HALT：停止CPU的工作</li>
<li>IN/OUT：执行I/O操作</li>
</ul>
</li>
<li>最高权限</li>
<li>用户态向核态
<ul>
<li>用户请求os提供服务</li>
<li>用户态企图执行特权指令</li>
<li>发生错误（内部中断）</li>
<li>发生中断</li>
</ul>
</li>
<li>核态-&gt;用户态
<ul>
<li>一般是中断返回：IRET</li>
</ul>
</li>
</ul>
<h3 id="存储体系">存储体系</h3>
<ul>
<li>实际体系
<ul>
<li>寄存器</li>
<li>高速缓存</li>
<li>主存</li>
<li>磁盘</li>
</ul>
</li>
</ul>
<h3 id="中断机制">中断机制</h3>
<ul>
<li>定义
<ul>
<li>指CPU对突发的外部信号的反应过程或机制</li>
<li>CPU收到外部信号后，停止当前操作，处理外部事件，处理完回到原来工作的中断处。</li>
</ul>
</li>
<li>中断源
<ul>
<li>引发中断的事件</li>
</ul>
</li>
<li>中断类型
<ul>
<li>强迫中断和自愿中断
<ul>
<li>强迫：程序没预期，（外部中断</li>
<li>自愿：程序有预期。（int 21h 访管指令)</li>
</ul>
</li>
</ul>
</li>
<li>外中断，内中断
<ul>
<li>外：外部事件引起，I/O
<ul>
<li>不可屏蔽中断：中断原因很紧要，CPU必须相应</li>
<li>可屏蔽中断：CPU可以选择响应</li>
</ul>
</li>
<li>内：内部事件引起</li>
</ul>
</li>
<li>断点
<ul>
<li>程序中断的地方
<ul>
<li>将要执行的下一条指令位置(CS:IP)</li>
</ul>
</li>
</ul>
</li>
<li>现场
<ul>
<li>程序正确运行所依赖的信息集合</li>
<li>PSW（程序状态字），相关寄存器，断点</li>
</ul>
</li>
<li>现场处理
<ul>
<li>保护：状态-&gt;栈</li>
<li>恢复：栈-&gt;状态</li>
</ul>
</li>
<li>中断响应过程
<ol>
<li>中断信号</li>
<li>断电入栈</li>
<li>现场入栈</li>
<li>进入中断服务</li>
<li>现场出栈</li>
<li>中断返回</li>
</ol>
</li>
<li>中断的目的
<ul>
<li>实现并发活动</li>
<li>实现实时处理</li>
<li>故障自动处理</li>
</ul>
</li>
<li>中断程序
<ul>
<li>填写中断向量表</li>
<li>填写中断描述符表</li>
</ul>
</li>
<li>中断嵌套处理
<ul>
<li>高优先级打断低优先级中断服务</li>
</ul>
</li>
<li>中断响应的实质
<ul>
<li>交换指令执行的地址</li>
<li>交换CPU的态</li>
</ul>
</li>
<li>工作
<ul>
<li>现场保护和恢复</li>
<li>参数传递</li>
</ul>
</li>
<li>引入中断的目的
<ul>
<li>实现并发</li>
<li>实现实时处理</li>
<li>故障自动处理</li>
</ul>
</li>
</ul>
<h3 id="bios">BIOS</h3>
<ul>
<li>系统BIOS
<ul>
<li>固件</li>
<li>地址范围：F0000- FFFFF</li>
</ul>
</li>
<li>功能
<ul>
<li>加电自检(POST)
<ul>
<li>初始化基本硬件</li>
<li>自检错误通过喇叭鸣叫</li>
<li>按下PowerON开始执行POST</li>
<li>计算首条指令在<em>FFFF0</em>单元</li>
<li><code>JMP POST</code></li>
</ul>
</li>
<li>设置CMOS
<ul>
<li>交互式设置系统参数</li>
</ul>
</li>
<li>基本I/O功能
<ul>
<li>BIOS中断</li>
</ul>
</li>
<li>post之后
<ul>
<li>依次查找其他设备并初始化</li>
<li>查找显卡，执行显卡BIOS（C0000-C7FFF）</li>
<li>查找IDE控制器（C8000-CBFFF）</li>
<li>显示启动信息
<ul>
<li>各组件版权信息</li>
</ul>
</li>
<li>查找/设置其他外设
<ul>
<li>配置寄存器</li>
<li>启动设备BIOS</li>
</ul>
</li>
</ul>
</li>
<li>系统自举/加载OS
<ul>
<li>现场引导方式</li>
<li>下载引导方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mode">mode</h3>
<ul>
<li>实模式
<ul>
<li>按照8086访问1MB空间</li>
<li>寻址方式：物理地址（20）=段地址：偏移地址</li>
<li>CPU单任务运行</li>
<li>实模式的1M空间
<ul>
<li>前面640K 【00000 -- 9FFFF】：基本内存</li>
<li>中间128K 【A0000 -- BFFFF】：显卡显存</li>
<li>末尾256K 【C0000 -- FFFFF】：BIOS</li>
</ul>
</li>
</ul>
</li>
<li>保护模式
<ul>
<li>寻址方式：段（16bit）和偏移量（32bit），寻址4gb</li>
<li>CPU支持多任务</li>
</ul>
</li>
</ul>
<h3 id="启动过程">启动过程</h3>
<ul>
<li>从加电到用户工作环境准备好的过程</li>
</ul>
<ol>
<li>初始引导
<ul>
<li>把OS内核装入内存并使之接管计算机系统</li>
<li>引导程序：MBR
<ul>
<li>GRUB</li>
<li>bootmgr|NTLDR|LILO</li>
</ul>
</li>
</ul>
</li>
<li>核心初始化
<ul>
<li>OS内核准备数据.</li>
<li>典型工作
<ul>
<li>各种寄存器的初始化</li>
<li>存储系统和页表初始化</li>
<li>核心进程构建</li>
</ul>
</li>
</ul>
</li>
<li>系统初始化
<ul>
<li>为用户使用系统作准备</li>
<li>主要工作
<ul>
<li>初始化文件系统</li>
<li>初始化网络系统</li>
<li>初始化控制台</li>
<li>初始化图形界面</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="mbr">MBR</h3>
<ul>
<li>主启动扇区</li>
<li>存放引导代码
<ul>
<li>启动相关的数据和代码</li>
</ul>
</li>
<li>512B=510字节+AA55h</li>
<li>PBR：分区/次引导记录</li>
<li>提供BootLoader或启动管理
<ul>
<li>直接指向引导代码加载OS</li>
<li>提供启动选项菜单</li>
<li>跳转到PBR以加载特定OS BootLoader</li>
</ul>
</li>
<li>安装过程
<ul>
<li>把OS映像拷贝到存储空间</li>
<li>写启动相关代码和数据
<ul>
<li>MBR扇区</li>
<li>PBR扇区</li>
<li>512字节</li>
</ul>
</li>
</ul>
</li>
<li>多操作系统安装
<ul>
<li>MBR重写vs. MBR追加</li>
<li>安装顺序</li>
</ul>
</li>
</ul>
<h3 id="windos启动过程">windos启动过程</h3>
<ul>
<li>POST
<ul>
<li>加电后IOS启动主机自检程序</li>
</ul>
</li>
<li>初始引导
<ul>
<li>BIOS从MBR读入引导程序，装入内存的特定位置</li>
<li>引导程序启动DOS7.0，调入操作系统核心</li>
<li>WINDOWS开始接管系统</li>
</ul>
</li>
<li>核心初始化
<ul>
<li>资源状态、核心数据等初始化</li>
</ul>
</li>
<li>系统初始化
<ul>
<li>GUI界面生成，系统处于待命/消息接受状态</li>
</ul>
</li>
</ul>
<h3 id="linux启动过程">linux启动过程</h3>
<p>POST →<br>
MBR →<br>
KERNEL映像→<br>
KERNEL映像边自解压并边执行→<br>
内核初始化→<br>
内核启动→<br>
init进程→</p>
<h2 id="用户环境">用户环境</h2>
<ul>
<li>用户工作的软件
<ul>
<li>桌面环境</li>
<li>命令行环境</li>
</ul>
</li>
</ul>
<h3 id="用户环境构造">用户环境构造</h3>
<ul>
<li>按照用户要求和硬件特性安装和配置操作系统。
<ul>
<li>提供操作命令和界面</li>
<li>提供系统用户手册</li>
</ul>
</li>
</ul>
<h2 id="用户界面">用户界面</h2>
<h3 id="定义">定义</h3>
<ul>
<li>操作系统提供给用户控制计算机的机制(用户接口)</li>
</ul>
<h3 id="类型">类型</h3>
<ul>
<li>操作界面</li>
<li>系统调用(System Call，系统功能调用,程序界面)</li>
</ul>
<h2 id="操作界面">操作界面</h2>
<h3 id="类型-2">类型</h3>
<ul>
<li>图形用户接口</li>
<li>操作命令（普通命令）</li>
<li>批处理与脚本程序</li>
</ul>
<h3 id="批处理与脚本程序">批处理与脚本程序</h3>
<ul>
<li>在控制台环境下自动处理一批命令
<ul>
<li>Windows：批处理程序（bat/PowerShell）
<ul>
<li>特点
<ul>
<li>普通命令的集合，按批执行，由command解释执行</li>
<li>支持变量替换、条件、转移、循环、注释等语法</li>
<li>文件后缀*.BAT，解释执行</li>
</ul>
</li>
</ul>
</li>
<li>Linux： Shell脚本程序
<ul>
<li>特点：
<ul>
<li>脚本程序是有一定逻辑顺序和语法结构的命令序列，能完成较复杂的功能和人机交互。</li>
<li>所有命令按逻辑逐行执行</li>
<li>脚本程序是文本文件（具有可执行属性X）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>shell是操作系统与用户的交互机制（操作界面）
<ul>
<li>通过Shell(/控制台)执行用户命令</li>
<li>组织和管理用户命令的执行和结果展示</li>
</ul>
</li>
</ul>
<h4 id="dos命令">dos命令</h4>
<ul>
<li>文件管理
<ul>
<li>COPY、COMP、TYPE、DEL、REN</li>
</ul>
</li>
<li>磁盘管理
<ul>
<li>FORMAT、CHKDSK、DISKCOPY、DISKCOMP</li>
</ul>
</li>
<li>目录管理
<ul>
<li>DIR、CD、MD、RD、TREE</li>
</ul>
</li>
<li>设备工作模式
<ul>
<li>CLS、MODE</li>
</ul>
</li>
<li>日期、时间、系统设置
<ul>
<li>DATE、TIME、VER、VOL</li>
</ul>
</li>
<li>运行用户程序
<ul>
<li>MASM、LINK、DEBUG</li>
</ul>
</li>
</ul>
<h4 id="linux典型命令">Linux典型命令</h4>
<table>
<thead>
<tr>
<th>ls</th>
<th>列举子目录和文件</th>
<th>find</th>
<th>查找文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>ps</td>
<td>列举进程</td>
<td>whereis</td>
<td>查找文件目录</td>
</tr>
<tr>
<td>top</td>
<td>列举进程</td>
<td>man</td>
<td>查看命令帮助信息</td>
</tr>
<tr>
<td>echo</td>
<td>输出字符串</td>
<td>cp</td>
<td>拷贝</td>
</tr>
<tr>
<td>cat</td>
<td>读取内容</td>
<td>inode</td>
<td>查看文件节点</td>
</tr>
<tr>
<td>cd</td>
<td>改变目录</td>
<td>tar</td>
<td>压缩和解压</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件属性</td>
<td>rm</td>
<td>删除文件和文件夹</td>
</tr>
<tr>
<td>mount</td>
<td>挂载文件系统</td>
<td>umount</td>
<td>卸载文件系统</td>
</tr>
<tr>
<td>insmod</td>
<td>安装模块</td>
<td>rmmod</td>
<td>卸载模块</td>
</tr>
</tbody>
</table>
<h2 id="系统调用">系统调用</h2>
<ul>
<li>操作系统内核为应用程序提供的服务/函数。</li>
<li>特点
<ul>
<li>内核实现</li>
<li>存取核心资源或硬件</li>
<li>调用过程产生中断
<ul>
<li>用户态↔ 核态</li>
<li>自愿中断</li>
</ul>
</li>
</ul>
</li>
<li>系统调用表
<ul>
<li>全部系统调用的入口列表
<ul>
<li>有序排列</li>
</ul>
</li>
<li>系统调用号：系统调用的唯一编号</li>
</ul>
</li>
<li>系统调用的一般调用形式
<ul>
<li>访管指令： SVC X
<ul>
<li>SVC = SuperVisor Call</li>
<li>X = 系统调用的编号</li>
</ul>
</li>
</ul>
</li>
<li>具体OS中系统调用的调用形式
<ul>
<li>DOS： INT 21H + AH</li>
<li>Linux：INT 80H + EAX
<ul>
<li>INT XXH = SVC指令</li>
<li>AH/EAX = 系统调用的编号：N</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="进程概念">进程概念</h2>
<h3 id="定义-2">定义</h3>
<ul>
<li>进程是程序在某个数据集合上的一次运行活动</li>
<li>数据集合：软硬件环境，多个进程共存/共享的环境</li>
</ul>
<h3 id="进程特征">进程特征</h3>
<ul>
<li>动态性
<ul>
<li>进程是程序的一次执行过程，动态产生/消亡</li>
</ul>
</li>
<li>并发性
<ul>
<li>进程可以同其他进程一起向前推进</li>
</ul>
</li>
<li>异步性
<ul>
<li>进程按各自速度向前推进</li>
</ul>
</li>
<li>独立性
<ul>
<li>进程是系统分配资源和调度CPU的单位</li>
</ul>
</li>
</ul>
<h3 id="进程与程序的区别">进程与程序的区别</h3>
<ul>
<li>动态与静态
<ul>
<li>进程是动态的：程序的一次执行过程</li>
<li>程序是静态的：一组指令的有序集合</li>
</ul>
</li>
<li>暂存与长存
<ul>
<li>进程是暂存的：在内存驻留</li>
<li>程序是长存的：在介质上长期保存。</li>
</ul>
</li>
<li>程序和进程的对应
<ul>
<li>一个程序可能有多个进程</li>
</ul>
</li>
</ul>
<h3 id="进程的状态">进程的状态</h3>
<ul>
<li>运行状态
<ul>
<li>进程已经占有CPU，在CPU上运行</li>
</ul>
</li>
<li>就绪状态
<ul>
<li>具备运行条件但由于无CPU，暂时不能运行</li>
</ul>
</li>
<li>阻塞状态
<ul>
<li>因为等待某项服务完成或信号来到而不能运行的状态</li>
<li>例如等待：系统调用，I/O操作，合作进程的服务或信号</li>
</ul>
</li>
<li>进程状态的变迁
<ul>
<li>进程的状态可以依据一定的条件相互转化</li>
<li>服务：系统调用/ I/O
<ul>
<li>就绪-&gt;运行：进程调度</li>
<li>运行-&gt;就绪：时间片到；被抢占</li>
<li>运行-&gt;阻塞：服务请求；等待信号</li>
<li>阻塞-&gt;就绪：服务完成；信号来到</li>
</ul>
</li>
</ul>
</li>
<li>具有新建(new)和终止(terminate)状态的进程状态
<ul>
<li>状态机<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231231150335.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>支持挂起(suspend)和解挂(resume)操作的进程状态
<ul>
<li>阻塞
<ul>
<li>活动阻塞（正常阻塞）</li>
<li>静止阻塞（阻塞时挂起）</li>
</ul>
</li>
<li>就绪
<ul>
<li>活动就绪（正常就绪）</li>
<li>静止就绪（就绪时挂起）</li>
</ul>
</li>
<li>与挂起相关的迁移
<ul>
<li>运行--&gt;静止就绪：挂起</li>
<li>活动就绪-&gt;静止就绪：挂起</li>
<li>活动阻塞-&gt;静止阻塞：挂起</li>
<li>静止就绪-&gt;活动就绪：解挂</li>
<li>静止阻塞-&gt;活动阻塞：解挂</li>
<li>静止阻塞-&gt;静止就绪：期待的事件/信号发生</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制块pcb">进程控制块PCB</h3>
<ul>
<li>描述进程的状态、资源、和相关进程的关系。</li>
<li>PCB是进程的标志</li>
<li>创建进程时创建PCB；进程撤销后PCB同时撤销。</li>
<li>进程＝ 程序＋ PCB</li>
<li>基本成员
<ul>
<li>name（ID）：进程名称（标识符）</li>
<li>state：状态/status</li>
<li>priority：优先级</li>
<li>start_addr：程序入口地址</li>
<li>next：指向下一个PCB的指针</li>
<li>cpu_status：现场保留区(堆栈)</li>
<li>comm_info：进程通信机制/信号机制</li>
<li>process_family：家族关系</li>
<li>own_resource：资源清单</li>
</ul>
</li>
<li>linux实现<pre><code class="language-C++">struct  task_struct{
/* these are hardcoded  - don't touch*/
long stat;  //进程的运行状态  （-1 unrunnable  ,1 runnable , 0 stopped）

long counter;  //进程的执行时间片，表示当前进程能够占用CPU资源的时间

long signal;  //信号量位图32bit每一个bit来表示一个信号

struct sigaction sigaction[32];  //信号量
long blocked;  //信号掩码  

/* various fields*/
int exit_code; //退出码

unsigned long start_code,end_code,end_data,brk,start_stack; //当前进程的内存使用信息

long pid,father,pgrp,session,leader; //pid 

unsigned short uid,euid,suid; //进程的用户ID，进程的有效ID，进程的超级ID

unsigned short gid,egid,sgid;  //进程组ID，进程的有效组ID，进程的超级组ID

long alarm; //进程的警告标志

long utime,stime,cutime,cstime,start_time;  //有关进程的用户时间，系统时间当前用户时间等

unsigned short used_math;  //是否使用协处理器

/*file  system info*/
int tty;  //当前进程是否占用控制台

unsigned short umask; //用户的掩码

struct m_inode * pwd;  //路径

struct m_inode * root;  //根目录

struct m_inode * excutable; // 执行位图

unsigned long close_on_exec; // 执行结束后关闭位图

struct file * fds[NUMFD];  //当前进程的文件列表FD在这个数组中找到一个file结构体

struct desc_struct ldt[3];

struct tss_struct tss;

}
</code></pre>
</li>
</ul>
<h3 id="进程的上下文和进程切换">进程的上下文和进程切换</h3>
<ul>
<li>进程的上下文
<ul>
<li>Context，进程运行环境</li>
</ul>
</li>
<li>分时系统的进程切换过程
<ul>
<li>进程的上下文在CPU中交换</li>
<li>换入进程上下文进入CPU(从栈+PCB上来)</li>
<li>换出进程上下文离开CPU(到栈+PCB上去)</li>
</ul>
</li>
</ul>
<h2 id="进程控制">进程控制</h2>
<ul>
<li>在进程生存全期间，对其全部行为的控制</li>
<li>四个典型的进程控制</li>
</ul>
<h3 id="进程创建">进程创建</h3>
<ul>
<li>功能
<ul>
<li>创建一个具有指定标识（ID）的进程</li>
</ul>
</li>
<li>参数
<ul>
<li>进程标识、优先级、进程起始地址、CPU初始状态、资源清单等</li>
</ul>
</li>
<li>创建进程的过程
<ul>
<li>创建一个空白PCB</li>
<li>赋予进程标识符ID</li>
<li>为进程分配空间</li>
<li>初始化PCB
<ul>
<li>默认值</li>
</ul>
</li>
<li>插入相应的进程队列
<ul>
<li>新进程插入就绪队列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程撤销">进程撤销</h3>
<ul>
<li>功能
<ul>
<li>撤销一个指定的进程</li>
<li>收回进程所占有的资源，撤销该进程的PCB</li>
</ul>
</li>
<li>进程撤销的时机/事件
<ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
<li>参数
<ul>
<li>撤销进程的ID</li>
</ul>
</li>
<li>进程撤销的实现
<ul>
<li>在PCB队列中检索出该PCB</li>
<li>获取该进程的状态。</li>
<li>若该进程处在运行态，立即终止该进程&gt;
<ul>
<li>先撤销子进程【递归/可选】</li>
<li>或将字进程挂接到init进程下</li>
</ul>
</li>
<li>释放进程占用的资源</li>
<li>将进程从PCB队列中移除</li>
</ul>
</li>
</ul>
<h3 id="阻塞进程">阻塞进程</h3>
<ul>
<li>功能
<ul>
<li>停止进程执行，变为阻塞。</li>
</ul>
</li>
<li>阻塞的时机/事件
<ul>
<li>请求系统服务
<ul>
<li>（由于某种原因，OS不能立即满足进程的要求）</li>
</ul>
</li>
<li>启动某种操作
<ul>
<li>（进程启动某操作，阻塞等待该操作完成）</li>
</ul>
</li>
<li>新数据尚未到达
<ul>
<li>（A进程要获得B进程的中间结果，A进程等待）</li>
</ul>
</li>
<li>无新工作可作(idle进程：pause( )
<ul>
<li>（进程完成任务后，自我阻塞，等待新任务到达）</li>
</ul>
</li>
</ul>
</li>
<li>参数
<ul>
<li>阻塞原因</li>
<li>不同原因构建有不同的阻塞队列。</li>
</ul>
</li>
<li>进程阻塞的实现
<ul>
<li>停止运行</li>
<li>将PCB “运行态”改“阻塞态”</li>
<li>插入对应的阻塞队列</li>
<li>转调度程序</li>
</ul>
</li>
</ul>
<h3 id="唤醒进程">唤醒进程</h3>
<ul>
<li>功能：
<ul>
<li>唤醒处于阻塞队列当中的某个进程。</li>
</ul>
</li>
<li>引起唤醒的时机/事件
<ul>
<li>系统服务由不满足到满足</li>
<li>I/O完成</li>
<li>新数据到达</li>
<li>提出新请求</li>
</ul>
</li>
<li>参数
<ul>
<li>进程的标识</li>
</ul>
</li>
</ul>
<h3 id="进程控制原语">进程控制原语</h3>
<ul>
<li>原语
<ul>
<li>由若干指令构成的具有特定功能的函数</li>
<li>具有原子性，其操作不可分割</li>
</ul>
</li>
<li>进程控制原语
<ul>
<li>创建原语| 撤消原语| 阻塞原语| 唤醒原语</li>
</ul>
</li>
</ul>
<h4 id="windos进程">windos进程</h4>
<ul>
<li>CreateProcess</li>
<li>创建新进程
<ul>
<li>创建进程内核对象，创建虚拟地址空间</li>
<li>装载EXE和/或DLL的代码和数据到地址空间中</li>
<li>创建主线程和线程内核对象</li>
<li>启动主线程，进入主函数（main）</li>
</ul>
</li>
<li>结束进程
<ul>
<li>ExitProcess
<ul>
<li><code>VOID ExitProcess(UINT uExitCode)</code></li>
</ul>
</li>
<li>TerminateProcess</li>
</ul>
<pre><code class="language-C++">VOID TerminateProcess (
	HANDLE hProcess,
	UINT uExitCode )
</code></pre>
</li>
</ul>
<h4 id="linux进程控制">linux进程控制</h4>
<ul>
<li>创建进程--fork</li>
<li>例子：<code>pid_t pid=fork()</code></li>
<li>父进程和子进程
<ul>
<li>子进程：新建的进程</li>
<li>父进程：fork( )的调用者</li>
<li>子进程是父进程的复制</li>
<li>父进程和子进程并发运行。</li>
</ul>
</li>
<li>关于fork 的返回值：pid
<ul>
<li>pid = 0（在子进程中）</li>
<li>pid &gt; 0（在父进程中）（子进程ID）</li>
<li>pid = -1 （出错）</li>
</ul>
</li>
<li>fork( )执行流程
<ul>
<li>分配task_struct结构</li>
<li>拷贝父进程
<ul>
<li>复制页表
<ul>
<li>复制正文段、用户数据段及系统数据段</li>
</ul>
</li>
<li>复制task_struct
<ul>
<li>修改task_struct小部分内容</li>
</ul>
</li>
</ul>
</li>
<li>把新进程加入进程列表。</li>
<li>置新进程为就绪状态</li>
<li>fork ( ) → sys_fork ( ) → do_fork( )</li>
</ul>
</li>
<li>进程的阻塞wait( )
<ul>
<li>检测有无子进程结束?
<ul>
<li>没有:
<ul>
<li>继续阻塞：等待子进程结束。</li>
</ul>
</li>
<li>有:
<ul>
<li>收集该子进程信息并彻底销毁它，返回。</li>
</ul>
</li>
</ul>
</li>
<li>Status接收子进程退出时的退出代码。
<ul>
<li>status：按位处理</li>
<li>若忽略子进程的退出信息<code>pid =wait(NULL)</code></li>
</ul>
</li>
</ul>
</li>
<li>进程的终结exit( )
<ul>
<li>调用void exit(int status)终结进程</li>
<li>进程终结时要释放资源并向父进程报告
<ul>
<li>利用status向父进程报告结束时的退出代码</li>
<li>变为僵尸状态，保留部分PCB信息供wait收集
<ul>
<li>正常结束还是异常结束</li>
<li>占用总系统cpu时间</li>
<li>缺页中断次数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>进程的休眠Sleep( )
<ul>
<li>进程暂停执行nSecond秒</li>
<li>系统暂停调度该进程</li>
<li>相当于windows挂起操作resume( )，挂起指定秒</li>
</ul>
</li>
</ul>
<h2 id="线程">线程</h2>
<h3 id="进程的并发性">进程的并发性</h3>
<ul>
<li>进程与进程可以并发运行(共享CPU)</li>
<li>进程是系统中<em>共享CPU</em>的<em>最小</em>的并发单位
<ul>
<li>进程内部的指令和函数都是串行执行的</li>
<li>若多个任务要并发，则必须设计相应数量的程序。</li>
</ul>
</li>
</ul>
<h3 id="定义-3">定义</h3>
<ul>
<li>线程是进程内创建的可运行模块/指令序列，能执行指定的任务。</li>
<li>进程内可以定义多个线程</li>
<li>线程和线程可以并发运行。</li>
</ul>
<h3 id="意义">意义</h3>
<ul>
<li>线程提高了系统的并发性能
<ul>
<li>线程的并发粒度比进程更细</li>
<li>更充分地发挥CPU的性能</li>
</ul>
</li>
<li>线程的应用成本更低，更灵活
<ul>
<li>进程为线程提供资源和地址空间
<ul>
<li>线程的创建，撤销和管理成本更低</li>
<li>线程间通信更容易，更灵活</li>
</ul>
</li>
</ul>
</li>
<li>大多数操作系统都采用了线程技术</li>
</ul>
<h3 id="线程创建windos">线程创建(windos)</h3>
<ul>
<li>功能：创建一个线程同时为其指定任务(TaskFunction)。</li>
<li>原型</li>
</ul>
<pre><code class="language-C++">HANDLE CreateThread (
LPSECURITY_ATTRIBUTES lpThreadAttributes,
DWORD dwStackSize,
LPTHREAD_ROUTINE ThreadFunction, //线程函数
LPVOID lpParameter //线程函数的参数
)
</code></pre>
<h3 id="linux线程和分类">Linux线程和分类</h3>
<h4 id="内核线程">内核线程</h4>
<ul>
<li>内核线程/Kernel Thread</li>
<li>创建函数：kthread_create( )</li>
<li>创建、运行和撤销都在内核完成，由内核驱动。</li>
<li>内核线程没有独立的地址空间mm=NULL
<ul>
<li>只在内核空间运行，不切换到用户空间；</li>
</ul>
</li>
</ul>
<h4 id="用户线程">用户线程</h4>
<ul>
<li>通过pthread线程库创建和管理</li>
<li>线程库提供同步和调度的方法。</li>
<li>用户线程不是真正的调度实体，内核对它们一无所知。
<ul>
<li>当一个进程被抢占时，它的所有用户线程都被抢占</li>
<li>当一个用户线程被阻塞时，它会阻塞其所属的进程</li>
</ul>
</li>
<li>用pthread创建线程<pre><code class="language-C++">int pthread_create( pthread_t * thread,
	pthread_attr_t * attr,
	void *(*ThreadFunc)(void *),
	void * arg);
</code></pre>
<ul>
<li>创建函数：clone( )</li>
</ul>
</li>
</ul>
<h2 id="同步互斥">同步/互斥</h2>
<h3 id="进程互斥的定义">进程互斥的定义</h3>
<ul>
<li>多个进程共享具有独占性的资源时，必须确保各进程互斥地存<br>
取资源，即确保没有任何两个进程同时存取资源。</li>
<li>进程内设定特定区域，所有进程互斥地访问这些区域。</li>
</ul>
<h3 id="同步关系">同步关系</h3>
<ul>
<li>若干合作进程为了共同完成一个任务，需要相互协调运行步伐：一个进程A开始某个操作之前要求另一个进程B必须已经完成另一个操作，否则进程A只能等待</li>
<li>合作进程中某些操作之间需要满足某种先后关系或某个操作能否进行需要某个前提条件满足，否则只能等待。</li>
<li>互斥关系属于特殊的同步关系。</li>
</ul>
<h3 id="同步机制">同步机制</h3>
<ul>
<li>功能
<ol>
<li>当进程的某个操作不能执行时（即运行条件不满足时）能让该进程立即暂停执行；</li>
<li>当暂停的操作条件一旦满足时，能被立即唤醒继续运行。</li>
<li>同步进制在实现上需要满足原子性。</li>
</ol>
</li>
</ul>
<h3 id="临界资源">临界资源</h3>
<ul>
<li>一次只允许一个进程独占访问（使用）的资源</li>
</ul>
<h3 id="临界区">临界区</h3>
<ul>
<li>进程中访问临界资源的程序段。</li>
</ul>
<h3 id="临界区和临界资源的共享特点">临界区和临界资源的共享特点</h3>
<ul>
<li>临界资源的访问具有排他性；</li>
<li>并发进程不能同时进入“临界区”</li>
</ul>
<h3 id="访问临界区的方法">访问临界区的方法</h3>
<h4 id="硬件方法">硬件方法</h4>
<ul>
<li>中断屏蔽方法
<ul>
<li>进入临界区前
<ul>
<li>执行“关中断”指令</li>
</ul>
</li>
<li>离开临界区后
<ul>
<li>执行“开中断”指令</li>
</ul>
</li>
</ul>
</li>
<li>测试并设置指令</li>
<li>交换指令</li>
</ul>
<h4 id="软件方法">软件方法</h4>
<ul>
<li>锁</li>
<li>信号量</li>
</ul>
<h3 id="设计临界区访问机制的四个原则">设计临界区访问机制的四个原则</h3>
<ul>
<li>忙则等待
<ul>
<li>当临界区忙时，其他进程必须在临界区外等待。</li>
</ul>
</li>
<li>空闲让进
<ul>
<li>当无进程处于临界区时，任何有权进程可进入临界区。</li>
</ul>
</li>
<li>有限等待
<ul>
<li>进程进入临界区的请求应在有限时间内得到满足</li>
</ul>
</li>
<li>让权等待
<ul>
<li>等待进程放弃CPU。（让其它进程有机会得到CPU）。</li>
</ul>
</li>
</ul>
<h2 id="锁">锁</h2>
<h3 id="基本原理">基本原理</h3>
<ul>
<li>设置一个“标志”S：
<ul>
<li>临界资源可用还是不可用？1:0</li>
</ul>
</li>
<li>在进入临界区之前检查标志是否“可用”？
<ul>
<li>若为“不可用”状态
<ul>
<li>进程在临界区之外等待</li>
</ul>
</li>
<li>若为“可用”状态
<ul>
<li>进入临界区,并将标志修改为“不可用”</li>
<li>在临界区内访问临界资源……</li>
</ul>
</li>
<li>退出临界区时
<ul>
<li>将标志修改为“可用”状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="信号量和p-v操作">信号量和P-V操作</h2>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>信号灯定义为一个二元矢量（S, q）</li>
<li>S：整数，初值非负（S又称信号量）</li>
<li>q：队列(进程PCB集合)，初值为空集</li>
</ul>
<h3 id="操作">操作</h3>
<ul>
<li>P操作（函数或过程）： P(S,q)
<ul>
<li>Passeren通过</li>
<li>第1步：S值减1</li>
<li>第2步：判断S&lt;0
<ul>
<li>若S大于或等于零，该进程继续</li>
<li>若S小于零，该进程阻塞并加入到q中，转调度函数</li>
</ul>
</li>
</ul>
</li>
<li>V操作（函数或过程）： V(S,q)
<ul>
<li>Vrijgeven释放</li>
<li>V操作可能会唤醒另一个正阻塞的进程。</li>
<li>第1步：S值加1</li>
<li>第2步：判断S &lt;= 0
<ul>
<li>若S大于零，该进程继续；</li>
<li>若S小于或等于零，该进程继续同时从q中唤醒一个进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="信号灯p-v操作的应用">信号灯P-V操作的应用</h3>
<ul>
<li>实现进程互斥
<ul>
<li>实现对临界区的互斥访问
<ul>
<li>1个临界资源：允许最多1个进程处于临界区</li>
<li>M个临界资源：允许最多M个进程同时处于临界区</li>
</ul>
</li>
<li>应用过程
<ul>
<li>进入临界区之前先执行P操作；</li>
<li>离开临界区之后再执行V操作；</li>
<li>S的初值设置要合理</li>
</ul>
</li>
</ul>
</li>
<li>利用信号灯P-V操作实现同步
<ul>
<li>同步机制实质
<ul>
<li>运行条件不满足时，能让进程暂停</li>
<li>运行条件满足时，能让进程立即继续</li>
</ul>
</li>
<li>P-V操作应用于进程同步的基本思路
<ul>
<li>在有条件执行的关键操作之前执行P操作</li>
<li>在作执行条件的关键操作之后执行V操作</li>
<li>定义有意义的信号量S，并设置合适的初值
<ul>
<li>信号量S能明确地表示“运行条件”，</li>
<li>不合理的初值不仅达不到同步的目的，还会发生死锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="经典同步问题">经典同步问题</h2>
<h2 id="windos和linux同步实现">windos和linux同步实现</h2>
<h3 id="windos">windos</h3>
<h4 id="临界区criticalsection">临界区CRITICALSECTION</h4>
<ul>
<li>在进程内使用，保证仅一个线程可以申请到该对象</li>
<li>临界区是临界资源的访问</li>
<li>相关api</li>
<li><code>InitializeCriticalSection()</code>初始化临界区</li>
<li><code>DeleteCriticalSection()</code>删除临界区</li>
<li><code>EnterCriticalSection()</code> 进入临界区</li>
<li><code>LeaveCriticalSection()</code>退出临界区</li>
<li>等待函数
<ul>
<li>等待目标对象变成有信号的状态就返回</li>
<li>WaitForMultipleObjects()</li>
<li>WaitForSingleObject( )</li>
</ul>
</li>
</ul>
<h4 id="互斥量mutex">互斥量mutex</h4>
<ul>
<li>保证只有一个线程或进程可以申请到该对象</li>
<li>可以跨进程使用</li>
<li>可以有名称</li>
<li>互斥量比临界区要消耗更多资源，速度慢</li>
<li>api<pre><code class="language-C++">HANDLE CreateMutex( //创建互斥量
	LPSECURITY_ATTRIBUTES IpMutexAttributes,
	BOOL bInitialOwner,// 初始化互斥量的状态 : 真或假
	LPCTSTR IpName ）// 名字，可为NULL但不能跨进程用 
	);
HANDLE OpenMutex(//打开一个存在的互斥量
	DWORD dwDesiredAccess
	BOOL bInheritHandle
	LPCTSTR IpName// 名字 
);
BOOL ReleaseMutex( HANDLE hMutex):
BOOL CloseHandle(//关闭互斥量
HANDLE hObject // 句柄
</code></pre>
</li>
</ul>
<h4 id="信号量semaphore">信号量semaphore</h4>
<ul>
<li>允许指定数目的多个进程/线程访问临界区</li>
<li>一种资源计数器，用于限制并发线程的数量</li>
<li>初始值可以设置为N，则允许N个进程/线程并发访问资源</li>
<li>api<pre><code class="language-C++">HANDLE CreateSemaphore( //创建信号量
	LPSECURITY ATTRIBUTES IpSemaphoreAttributes,// 安全属性
	LONG IInitialCount，// 初始值
	LONG IMaximumCount，// 最大值
	LPCTSTR lpName //名字 );
	HANDLE OpenSemaphore(//打打开信号量
	DWORD dwDesiredAccess，// 存取方式
	BOOL bInheritHandle， // 是否能被继承
	LPCTSTR IpName// 名字 
):
BOOL ReleaseSemaphore(//释放信号量
	HANDLE hSemaphore，// 句柄
	LONG IReleaseCount， // 释放数，让信号量的值增加的数量
	LPLONG IpPreviousCount // 得到释放前信号量的值，可为NULL
	);
BOOL CloseHandle(//关闭信号量
	HANDLE hObject
	);
</code></pre>
</li>
</ul>
<h4 id="事件event">事件event</h4>
<ul>
<li>用于通知一个或多个线程某事件出现或标识某操作已经完成</li>
<li>分类
<ul>
<li>自动重置的事件:使用WaitForSingleObiect等待到事件对象变为有信号状态后该事件对象自动变为无信号状态</li>
<li>人工重置的事件:使用WaitForSingleObiect等待到事件对象变为有信号状态后该事件对象的状态不变，除非人工重置事件。</li>
</ul>
</li>
<li>api<pre><code class="language-C++">HANDLE CreateEvent ( //创建事件对象
	LPSECURITY ATTRIBUTES pEventAttributes,// 安全属
	BOOL bManualReset，// 是否为人工重置
	BOOL bImitialState,// 初始状态是否为有信号状态
	LPCTSTR IpName //名字 
	):
HANDLE OpenEvent (//打开事件对象
	DWORD dwDesiredAccess，// 存取方式
	BOOL bInheritHandle， // 是否能够被继承
	LPCTSTR IpName// 名字 
	):
BOOL ResetEvent (//设置事件为无信号状态
	HANDLE hEvent // 句柄 ):
BOOL SetEvent (//设置事件有信号状态
	HANDLE hEvent // 句柄
	BOOL CloseHandle(//关闭事件对象
HANDLE hObiet //句柄
</code></pre>
</li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="定义-4">定义</h3>
<ul>
<li>两个或多个进程无限期地等待永远不会发生的条件<br>
的一种系统状态。</li>
<li>在两个或多个进程中，每个进程都已持有某种资源，但又继续申请其它进程已持有的某种资源。
<ul>
<li>每个进程都拥有其运行所需的部分资源，但又不足够运行，从而每个进程都不能向前推进，陷于阻塞状态。这种状态称死锁。</li>
</ul>
</li>
</ul>
<h3 id="原因">原因</h3>
<ul>
<li>系统资源有限
<ul>
<li>资源数目不足以满足所有进程的需要，引起进程对资源的竞争而产生死锁。</li>
</ul>
</li>
<li>并发进程的推进顺序不当
<ul>
<li>进程在运行过程中，请求和释放资源的顺序不当，导致进程产生死锁。</li>
</ul>
</li>
</ul>
<h3 id="关于死锁的一些结论">关于死锁的一些结论</h3>
<ul>
<li>陷入死锁的进程至少是2个</li>
<li>参与死锁的进程至少有2个已经占有资源</li>
<li>参与死锁的所有进程都在等待资源</li>
<li>参与死锁的进程是当前系统中所有进程的子集</li>
<li>死锁会浪费大量系统资源，甚至导致系统崩溃</li>
</ul>
<h3 id="死锁的必要条件">死锁的必要条件</h3>
<ul>
<li>互斥条件
<ul>
<li>资源具有独占性，进程互斥使用资源</li>
</ul>
</li>
<li>不剥夺条件
<ul>
<li>资源被访问完之前(即在释放前)不能被其他进程剥夺</li>
</ul>
</li>
<li>部分分配条件
<ul>
<li>进程所需资源逐步分配，需要时临时申请（等待分配）</li>
<li>占有一些资源，同时申请新资源</li>
</ul>
</li>
<li>环路条件
<ul>
<li>多个进程构成环路：环中每个进程已占用的资源被前一进程申请，而自己所需新资源又被环中后一进程所占用。</li>
</ul>
</li>
</ul>
<h3 id="预防死锁">预防死锁</h3>
<ul>
<li>通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁。
<ul>
<li>破坏互斥条件</li>
<li>破坏不剥夺条件</li>
<li>破坏部分分配条件(预先静态分配)</li>
<li>破坏环路条件(有序资源分配)</li>
</ul>
</li>
</ul>
<h3 id="检测和恢复死锁">检测和恢复死锁</h3>
<ul>
<li>允许死锁发生，但可通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统中已发生的死锁清除，将进程从死锁状态解脱出来</li>
<li>检测方法</li>
<li>恢复方法
<ul>
<li>撤消或挂起一些进程，以回收一些资源</li>
</ul>
</li>
<li>缺点
<ul>
<li>实现难度大</li>
</ul>
</li>
</ul>
<h2 id="定义-5">定义</h2>
<h3 id="调度定义">调度定义</h3>
<ul>
<li>schedule队列</li>
<li>在队列中按某种策略选择最合适的对象(执行相应操作)。</li>
<li>分类
<ul>
<li>长程调度（宏观调度/作业调度）作业：磁盘→内存</li>
<li>中程调度（交换调度）进程：就绪(内存)→交换空间</li>
<li>短程调度（进程调度）进程：就绪(内存)→CPU</li>
<li>I/O调度（设备调度）进程：阻塞(设备)→就绪</li>
</ul>
</li>
</ul>
<h3 id="进程调度">进程调度</h3>
<ul>
<li>在合适的时候以一定策略选择一个就绪进程运行.</li>
<li>目标
<ul>
<li>周转时间/平均周转时间</li>
<li>带权周转时间/平均带权周转时间</li>
</ul>
</li>
<li>周转时间
<ul>
<li>进程(或作业)提交给计算机到完成所花费的时间</li>
<li>周转时间t = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">完</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><msub><mi>t</mi><mi>c</mi></msub><mi mathvariant="normal">–</mi><mi mathvariant="normal">提</mi><mi mathvariant="normal">交</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">完成时间t_c – 提交时间t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord cjk_fallback">提</span><span class="mord cjk_fallback">交</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>——进程的提交时间（Start）</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">t_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>——进程的完成时间（Complete ）</li>
</ul>
</li>
<li>意义
<ul>
<li>说明进程在系统中停留时间的长短。</li>
</ul>
</li>
</ul>
</li>
<li>平均周转时间
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>=</mo><mi mathvariant="normal">（</mi><msub><mi>t</mi><mn>1</mn></msub><mo>+</mo><msub><mi>t</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>t</mi><mi>n</mi></msub><mi mathvariant="normal">）</mi><mi mathvariant="normal">/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">t = （t_1 + t_2 + … + t_n）/ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span><span class="mord">/</span><span class="mord mathdefault">n</span></span></span></span></li>
<li>所有进程的周转时间的平均</li>
<li>平均周转时间越短意味着：平均停留时间越短，系统吞吐量越大，资源利用率越高。</li>
</ul>
</li>
<li>带权周转时间w
<ul>
<li>w = 周转时间t ÷ 进程运行时间(进程大小) r=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi mathvariant="normal">/</mi><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t / t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ul>
<li>t：进程的周转时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ：进程的运行时间（run）</li>
<li>意义：进程在系统中的相对停留时间。</li>
</ul>
</li>
</ul>
</li>
<li>平均带权周转时间
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mo>=</mo><mi mathvariant="normal">（</mi><msub><mi>w</mi><mn>1</mn></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>w</mi><mi>n</mi></msub><mi mathvariant="normal">）</mi><mo>÷</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">w = （w_1 + w_2 + … + w_n）÷ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">（</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
<li>所有进程的带权周转时间的平均</li>
</ul>
</li>
</ul>
<h2 id="进程调度算法">进程调度算法</h2>
<h3 id="先来先服务调度">先来先服务调度</h3>
<ul>
<li>算法
<ul>
<li>按照作业进入系统的时间先后次序来挑选作业。先进入系统的作业优先被运行。</li>
</ul>
</li>
<li>特点
<ul>
<li>只考虑作业等候时间，不考虑作业大小(运行时间)</li>
<li>晚来的作业会等待较长时间</li>
<li>不利于晚来但是很短的作业</li>
</ul>
</li>
</ul>
<h3 id="短作业优先调度算法">短作业优先调度算法</h3>
<ul>
<li>算法
<ul>
<li>参考运行时间，选取时间最短的作业投入运行。</li>
</ul>
</li>
<li>特点/缺点
<ul>
<li>忽视了作业等待时间</li>
<li>早来的长作业会长时间等待(资源“饥饿”)</li>
</ul>
</li>
</ul>
<h3 id="响应比高者优先调度算法">响应比高者优先调度算法</h3>
<ul>
<li>响应比定义
<ul>
<li>作业的响应时间（等待时间+运行时间）和与运行时间的比值</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">响</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">比</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="normal">响</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">等</mi><mi mathvariant="normal">待</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="normal">加</mi><mi mathvariant="normal">权</mi><mi mathvariant="normal">周</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>(</mo><mi mathvariant="normal">当</mi><mi mathvariant="normal">前</mi><mi mathvariant="normal">的</mi><mo>)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned} 响应比 &amp;= 响应时间 / 运行时间 \\ &amp;= 1 + 等待时间/运行时间 \\ &amp;=加权周转时间(当前的) \end{aligned} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">比</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback">响</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">待</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">权</span><span class="mord cjk_fallback">周</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mopen">(</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">前</span><span class="mord cjk_fallback">的</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
</li>
<li>算法
<ul>
<li>调度作业时计算作业列表中每个作业的响应比，选择响应比最高的作业优先投入运行。</li>
</ul>
</li>
<li>特点
<ul>
<li>响应比= 1 + 等待时间/ 运行时间</li>
<li>有利于短作业</li>
<li>有利于等候已久的作业</li>
<li>兼顾长作业</li>
</ul>
</li>
<li>应用
<ul>
<li>每次调度时重新计算和比较剩余作业的响应比</li>
</ul>
</li>
</ul>
<h3 id="优先数调度算法">优先数调度算法</h3>
<ul>
<li>算法
<ul>
<li>根据进程优先数，把CPU分配给最高的进程。</li>
<li>进程优先数= 静态优先数+动态优先数</li>
</ul>
</li>
<li>静态优先数
<ul>
<li>进程创建时确定，在整个进程运行期间不再改变</li>
</ul>
</li>
<li>动态优先数
<ul>
<li>动态优先数在进程运行期间可以改变。</li>
</ul>
</li>
<li>静态优先数的确定
<ul>
<li>基于进程所需的资源多少</li>
<li>基于程序运行时间的长短</li>
<li>基于进程的类型</li>
</ul>
</li>
<li>动态优先数的确定
<ul>
<li>当进程使用CPU超过一定时长时；</li>
<li>当进程等待时间超过一定时长时</li>
<li>当进行I/O操作后</li>
</ul>
</li>
</ul>
<h3 id="循环轮转调度法">循环轮转调度法</h3>
<ul>
<li>算法
<ul>
<li>把所有就绪进程按先进先出的原则排成队列。新来进程加到队列末尾</li>
<li>进程以时间片q为单位轮流使用CPU。刚刚运行了一个时间片的进程排到队列末尾，等候下一轮调度。</li>
<li>队列逻辑上是环形的</li>
</ul>
</li>
<li>优点
<ul>
<li>公平性：每个就绪进程有平等机会获得CPU</li>
<li>交互性：每个进程等待(N-1)* q的时间就可以重新获得CPU</li>
</ul>
</li>
<li>时间片q的大小
<ul>
<li>如果q太大
<ul>
<li>交互性差
<ul>
<li>甚至退化为FCFS调度算法</li>
</ul>
</li>
</ul>
</li>
<li>如果q太小
<ul>
<li>进程切换频繁，系统开销增加</li>
</ul>
</li>
</ul>
</li>
<li>改进
<ul>
<li>时间片的大小可变（可变时间片轮转调度法)</li>
<li>组织多个就绪队列（多重时间片循环轮转）</li>
</ul>
</li>
</ul>
<h2 id="调度方式">调度方式</h2>
<h3 id="定义-6">定义</h3>
<ul>
<li>当一进程正在CPU上运行时，若有更高优先级的进<br>
程进入就绪，系统如何对待新进程（分配CPU）？</li>
</ul>
<h3 id="非抢占方式">非抢占方式</h3>
<ul>
<li>让正在运行的进程继续运行，直到该进程完成或发生某事件而进入“完成”或“阻塞”状态时，才把CPU分配给新来的更高优先级的进程。<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231231175124.png" alt="" loading="lazy"></li>
</ul>
<h3 id="抢占方式">抢占方式</h3>
<ul>
<li>让正在运行的进程立即暂停，立即把CPU分配给新来的优先级更高的进程。<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231231175206.png" alt="" loading="lazy"></li>
</ul>
<h2 id="linux进程调度">linux进程调度</h2>
<h3 id="基本特点">基本特点</h3>
<ul>
<li>基于优先级调度；</li>
<li>支持普通进程，也支持实时进程</li>
<li>实时进程优先于普通进程</li>
<li>普通进程公平使用CPU时间</li>
</ul>
<h3 id="linux进程优先级task_struct成员变量">LINUX进程优先级（task_struct成员变量）</h3>
<ul>
<li>priority/静态优先数</li>
<li>priority = priority - #</li>
<li>[-20～19]
<ul>
<li>普通用户：自己进程，[ 0, 19 ]</li>
<li>root用户：任何进程，[-20, 19 ]</li>
</ul>
</li>
<li>counter/动态优先数
<ul>
<li>初值= priority</li>
<li>用于实际比较的优先数</li>
<li>进程在当前一轮调度中还能连续运行的时间片数量</li>
<li>counter越大，优先级越高，可获得越多CPU时间</li>
<li>新一轮调度开始时
<ul>
<li>counter = priority</li>
</ul>
</li>
<li>时钟中断服务程序
<ul>
<li>counter - -</li>
</ul>
</li>
<li>特定情形
<ul>
<li>counter = counter + △</li>
</ul>
</li>
<li>所有进程的counter都减到0后
<ul>
<li>重新开始新一轮调度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存管理的功能">内存管理的功能</h2>
<h3 id="存储器功能需求">存储器功能需求</h3>
<ul>
<li>容量足够大</li>
<li>速度足够快</li>
<li>信息永久保存</li>
<li>多道程序并行</li>
</ul>
<h3 id="三级存储体系">三级存储体系</h3>
<ul>
<li>内存</li>
<li>辅存</li>
<li>cache</li>
<li>基本思想
<ul>
<li>用辅存支援内存，提高容量</li>
<li>用cahe支援内存，提高效率</li>
</ul>
</li>
</ul>
<h3 id="换出与换出辅存与内存">换出与换出（辅存与内存）</h3>
<ul>
<li>放入原来位置
<ul>
<li>程序简单</li>
<li>地址冲突</li>
</ul>
</li>
<li>任一位置
<ul>
<li>利用内存灵活</li>
<li>地址需要重定位</li>
</ul>
</li>
<li>地址重映射
<ul>
<li>重新确定指令中目标数据的正确地址（更新地址）</li>
<li>新的值与<strong>目标程序块</strong>的<strong>实际放置位置</strong>有关</li>
</ul>
</li>
</ul>
<h3 id="多道程序并行的问题">多道程序并行的问题</h3>
<ul>
<li>保护
<ul>
<li>禁止程序间越权访问</li>
</ul>
</li>
<li>共享
<ul>
<li>代码和数据共享，节省内存</li>
</ul>
</li>
</ul>
<h3 id="存储管理的功能">存储管理的功能</h3>
<h4 id="1地址映射">1.地址映射</h4>
<ul>
<li>定义
<ul>
<li>地址重定位，地址重映射</li>
<li>把程序中的地址（虚拟地址,虚地址,逻辑地址,相对地址）变换成真实的内存地址（实地址,物理地址,绝对地址）的过程
<ul>
<li>虚拟地址/源程序地址：地址，变量，标号，函数名</li>
</ul>
</li>
<li>逻辑地址
<ul>
<li>多道程序环境</li>
<li>目标模块/装入模块：使用内部的线性地址：[0~N)</li>
</ul>
</li>
<li>物理地址
<ul>
<li>内存单元的绝对地址
<ul>
<li>数据实际存放位置</li>
</ul>
</li>
<li>单道程序环境中、
<ul>
<li>程序装入的起始地址可以预知。</li>
<li>程序中直接指明数据/指令的物理地址。</li>
</ul>
</li>
<li>多道程序环境中
<ul>
<li>程序不能预知装入的地址</li>
<li>程序中无法明确地使用物理地址。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>固定地址映射
<ul>
<li>定义
<ul>
<li>编程或编译时确定逻辑地址和物理地址映射关系。</li>
</ul>
</li>
<li>特点
<ul>
<li>程序加载时必须加载到指定的内存区域。</li>
<li>容易产生地址冲突，运行失败。</li>
<li>不能适应多道程序环境</li>
</ul>
</li>
</ul>
</li>
<li>静态地址映射
<ul>
<li>定义
<ul>
<li>程序装入时由操作系统完成逻辑地址到物理地址的映射</li>
<li>保证程序在运行之前所有地址都绑定到主存</li>
</ul>
</li>
<li>映射方式
<ul>
<li>物理地址MA = 装入基址BA + 虚拟地址VA</li>
</ul>
</li>
<li>特点
<ul>
<li>程序运行之前确定映射关系</li>
<li>程序占用连续的内存空间</li>
<li>程序装入后不能移动
<ul>
<li>如果移动必须放回原来位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>动态地址映射
<ul>
<li>在程序执行过程中把逻辑地址转换为物理地址</li>
<li>映射方式
<ul>
<li>物理地址MA = 装入基址BA + 虚拟地址VA</li>
<li>装入基址：基址寄存器BAR</li>
<li>切换进程的同时切换基址寄存器BAR</li>
<li>IR = 指令寄存器
<ul>
<li>保存的是VA(虚拟地址)</li>
</ul>
</li>
</ul>
</li>
<li>程序可分配到不连续的多块内存中存放
<ul>
<li>按段编译
<ul>
<li>段内地址：线性地址</li>
</ul>
</li>
<li>按段装入，不同段放入不同内存块
<ul>
<li>每段维护一个段寄存器
<ul>
<li>段的重定位寄存器</li>
</ul>
</li>
</ul>
</li>
<li>段式存储管理</li>
<li>段的切换</li>
</ul>
</li>
<li>特点
<ul>
<li>程序占用的内存空间可动态变化</li>
<li>程序不要求占用连续的内存空间</li>
<li>便于多个进程共享代码</li>
</ul>
</li>
<li>缺点：
<ul>
<li>硬件支持（MMU：内存管理单元）</li>
<li>软件复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2存储扩充虚拟存储">2.存储扩充/虚拟存储</h4>
<ul>
<li>目的
<ul>
<li>程序过大或过多时，内存不够，不能运行</li>
<li>多个程序并发时地址冲突，不能运行</li>
</ul>
</li>
<li>解决1
<ul>
<li>借助辅存在逻辑上扩充内存，解决内存不足</li>
<li>迁入：装入将要运行的部分到内存</li>
<li>迁出：把不运行部分暂存到辅存上</li>
</ul>
</li>
<li>前提：
<ul>
<li>有适当容量的内存</li>
<li>有足够大的辅存</li>
<li>有地址变换机构</li>
</ul>
</li>
<li>应用：
<ul>
<li>页式虚拟存储</li>
<li>段式虚拟存储</li>
</ul>
</li>
</ul>
<h4 id="3内存分配">3.内存分配</h4>
<ul>
<li>为程序运行分配足够的内存空间</li>
<li>解决的问题
<ul>
<li>放置策略
<ul>
<li>程序调入到内存哪个/哪些区域</li>
</ul>
</li>
<li>调入策略
<ul>
<li>何时把要运行的程序调入内存？</li>
<li>预调策略| 请调策略</li>
</ul>
</li>
<li>淘汰策略
<ul>
<li>迁出（/淘汰）哪些程序以腾出内存空间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-存储保护">4. 存储保护</h4>
<ul>
<li>保证内存中的多道程序只能在给定区域活动，并且互不干扰。
<ul>
<li>防止访问越界</li>
<li>防止访问越权</li>
</ul>
</li>
<li>方法：
<ul>
<li>界址寄存器
<ul>
<li>上限地址寄存器/下限地址寄存器</li>
<li>基址寄存器和限长寄存器</li>
<li>适于连续物理分区中的情形</li>
</ul>
</li>
<li>存储键保护
<ul>
<li>适于不连续物理分块的情形，也可用于共享中的权限。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="物理内存管理">物理内存管理</h2>
<h3 id="单一区存储管理">单一区存储管理</h3>
<ul>
<li>定义
<ul>
<li>用户区不分区，完全被一个程序占用。</li>
</ul>
</li>
<li>优点
<ul>
<li>简单不需复杂硬件支持</li>
</ul>
</li>
<li>缺点
<ul>
<li>程序占用整个内存</li>
<li>内存浪费，利用率低</li>
</ul>
</li>
<li>场景
<ul>
<li>适于单用户单任务OS</li>
</ul>
</li>
</ul>
<h3 id="分区存储管理">分区存储管理</h3>
<ul>
<li>定义
<ul>
<li>把用户区分为若干大小不等的分区，供不同程序使用。</li>
</ul>
</li>
<li>分类
<ul>
<li>固定分区
<ul>
<li>系统初始化时分区</li>
<li>特点
<ul>
<li>运行时分区的大小和位置不变</li>
<li>分区大小不同，适应不同程序需求</li>
</ul>
</li>
<li>分区表
<ul>
<li>记录分区的位置、大小和占用标志</li>
</ul>
</li>
<li>缺点
<ul>
<li>浪费内存</li>
<li>大程序可能无法运行</li>
<li>程序过多无法运行</li>
</ul>
</li>
<li>应用
<ul>
<li>程序的装入数量和顺序要与分区的数量、大小顺序尽量保持一致。</li>
</ul>
</li>
</ul>
</li>
<li>动态分区
<ul>
<li>程序装入时临时分区</li>
<li>分区回收
<ul>
<li>收回占用分区，以便重新分配</li>
<li>回收时要考虑释放区和相邻区的合并</li>
</ul>
</li>
<li>分区再分配</li>
<li>特点
<ul>
<li>分区的个数和大小均可变</li>
<li>存在内存碎片（外部碎片）</li>
</ul>
</li>
<li>放置策略(分区的选择)
<ul>
<li>空闲区表
<ul>
<li>描述内存空闲区的位置和大小的数据结构</li>
</ul>
</li>
<li>首次适应法
<ul>
<li>空闲区表<em>按首址递增</em>排序</li>
<li>尽可能先利用低地址空间</li>
</ul>
</li>
<li>最佳适应法
<ul>
<li>空闲区表<em>按大小递增</em>排序</li>
<li>尽量先选中<strong>满足要求的最小</strong>空闲区</li>
</ul>
</li>
<li>最坏适应法
<ul>
<li>空闲区表<em>按大小递减</em>排序</li>
<li>尽量先使用<strong>最大的</strong>空闲区</li>
<li>仅作一次查找就可找到所要分区。</li>
</ul>
</li>
</ul>
</li>
<li>分区的分配
<ul>
<li>从用户选中的分区中分配/分割所需大小给用户</li>
<li>剩余部分（若有）依然作为空闲区登记</li>
<li>分割空闲区时一般把 <em>(底部)</em> 分割给用户(这样空闲区表就只需要修改大小)。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>容易产生内存碎片：内存反复分配和分割</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>内存碎片
<ul>
<li>过小的空闲区</li>
<li>难以实际利用</li>
<li>外部碎片
<ul>
<li>所有分区之外的碎片(单独的分区)</li>
</ul>
</li>
<li>内部碎片
<ul>
<li>分区内部出现的碎片。
<ul>
<li>固定分区的某分区剩下部分。</li>
<li>分⻚系统引起的⻚内碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>解决碎片的方法
<ul>
<li>规定门限值
<ul>
<li>分割空闲区时，若剩余部分小于门限值，则此空闲区不进行分割，而是全部分配给用户。</li>
</ul>
</li>
<li>内存拼接技术
<ul>
<li>将所有空闲区集中一起构成一个大的空闲区。</li>
<li>拼接的时机
<ul>
<li>释放区回收的时候</li>
<li>系统找不到足够大的空闲区时</li>
<li>定期</li>
</ul>
</li>
<li>缺点
<ul>
<li>消耗系统资源</li>
<li>离线拼接</li>
<li>重新定义作业</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="overlay覆盖">Overlay(覆盖)</h3>
<ul>
<li>在较小的内存空间中运行较大的程序</li>
<li>内存分区
<ul>
<li>常驻区：被某段单独且固定地占用的区域，可划分多个</li>
<li>覆盖区： 能被多段共用（覆盖）的区域， 可划分多个</li>
</ul>
</li>
<li>工作原理
<ul>
<li>程序分成若干代码段或数据段</li>
<li>将程序常用的段装入常驻区；（核心段）</li>
<li>将程序不常用段装入覆盖区；
<ul>
<li>正运行的段处于覆盖区；</li>
<li>暂时不运行的段放在硬盘中(覆盖文件)；</li>
<li>即将运行的段装入覆盖区（覆盖旧内容）；</li>
</ul>
</li>
</ul>
</li>
<li>缺点
<ul>
<li>编程复杂：程序员划分程序模块并确定覆盖关系。</li>
<li>程序执行时间长：从外存装入内存耗时</li>
</ul>
</li>
</ul>
<h3 id="swapping对换技术">Swapping（对换技术）</h3>
<ul>
<li>原理：
<ul>
<li>内存不够时把进程写到磁盘（换出/Swap Out ）。</li>
<li>当进程要运行时重新写回内存（换入/Swap In ）。</li>
</ul>
</li>
<li>优点：
<ul>
<li>增加进程并发数；</li>
<li>不考虑程序结构。</li>
</ul>
</li>
<li>缺点
<ul>
<li>换入和换出增加CPU开销；</li>
<li>对换单位太大（整个进程）：</li>
</ul>
</li>
<li>问题：
<ul>
<li>程序换入时的地址重定位</li>
<li>减少对换传送的信息量</li>
<li>外存对换空间的管理方法</li>
</ul>
</li>
</ul>
<h2 id="虚拟内存管理">虚拟内存管理</h2>
<h3 id="页式内存管理">页式内存管理</h3>
<h4 id="概念">概念</h4>
<ul>
<li>目的
<ul>
<li>小内存中运行大程序和多个程序</li>
</ul>
</li>
<li>程序和内存的划分
<ul>
<li>程序和内存都划成等大小（例4KB）的小片：页面和页框</li>
</ul>
</li>
<li>程序的装入方式
<ul>
<li>程序以页面为单位装入页框</li>
<li>内存以页框为单位使用</li>
</ul>
</li>
</ul>
<h4 id="原理">原理</h4>
<ul>
<li>程序运行的局部性
<ul>
<li>在任何有限时段内程序的运行活动一般局限在有限范围内。</li>
</ul>
</li>
<li>仅把程序的局部装入内存中
<ul>
<li>仅把当前时段涉及的部分页面装入内存(可让程序短暂运行)</li>
<li>运行过程逐步装入新页面
<ul>
<li>已运行过的旧页面可删除</li>
</ul>
</li>
</ul>
</li>
<li>确保有限时段内程序只占用了少量的内存。</li>
<li>进程装入和使用内存的原则
<ul>
<li>局部装入，不断更新
<ul>
<li>只把程序部分页装入内存便可运行。</li>
<li>页在内存中占用的页框不必相邻。</li>
<li>需要新页时，按需从硬盘调入内存。</li>
<li>不再运行的页及时删除，腾出空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="地址">地址</h4>
<ul>
<li>虚拟地址VA是线性的，从0开始</li>
<li>VA分成页号P和页内偏移W
<ul>
<li>P=VA/页大小</li>
<li>W=VA%页大小</li>
<li>计算方法<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231228201331.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>页面映射表（页表）
<ul>
<li>记录页面与页框(块)之间的对应关系。也叫页表。</li>
<li>页号：登记程序地址的页号。</li>
<li>页框号：登记页所在的物理页号。</li>
<li>页面其他特性：登记含存取权限在内的其他特性。</li>
<li>建立
<ul>
<li>操作系统为每个进程建立一个页表
<ul>
<li>页表的基址存放在进程控制块中</li>
<li>页表的内容由内核负责填充和更新</li>
</ul>
</li>
<li>当前进程的页表驻留在内存
<ul>
<li>页表基址：页表基址寄存器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>地址映射
<ul>
<li>虚拟地址(页式地址)-&gt;物理地址</li>
<li>步骤：
<ol>
<li>计算P，W</li>
<li>根据页表，得到页框号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">P&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>计算MA=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup><mo>×</mo><mi mathvariant="normal">页</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">小</mi><mo>+</mo><mi mathvariant="normal">页</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">偏</mi><mi mathvariant="normal">移</mi><mi>W</mi><mo>=</mo><msup><mi>P</mi><mo mathvariant="normal">′</mo></msup><mo>&lt;</mo><mo>&lt;</mo><mi>n</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">页</mi><mi mathvariant="normal">内</mi><mi mathvariant="normal">偏</mi><mi mathvariant="normal">移</mi></mrow><annotation encoding="application/x-tex">P&#x27;\times页大小+页内偏移W=P&#x27;&lt;&lt;n||页内偏移</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.835222em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">小</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.790992em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">移</span></span></span></span></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="缺页中断">缺页中断</h4>
<ul>
<li>定义
<ul>
<li>当程序要访问的目标页面不在内存时，程序将被迫临时中断：缺页中断</li>
</ul>
</li>
<li>处理
<ul>
<li>立即将所缺页面装入内存</li>
<li>页面从硬盘拷贝到内存
<ul>
<li>I/O操作，耗时较长</li>
</ul>
</li>
<li>缺页中断降低了程序实时性</li>
</ul>
</li>
<li>扩充有中断位I和辅存地址的页表
<ul>
<li>中断位I ——标识该页是否在内存?
<ul>
<li>若I =１，不在内存</li>
<li>若I =０，在内存q</li>
</ul>
</li>
<li>辅存地址——该页在辅存上的位置</li>
</ul>
</li>
<li>扩充有访问位（引用位）和修改位（Dirty）的页表
<ul>
<li>访问位——标识该页最近是否被访问？
<ul>
<li>０——最近没有被访问</li>
<li>１——最近已被访问</li>
</ul>
</li>
<li>修改位——标识该页的数据是否已被修改？
<ul>
<li>０——该页未被修改</li>
<li>１——该页已被修改</li>
</ul>
</li>
</ul>
</li>
<li>缺页中断处理程序
<ul>
<li>中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位I为0。</li>
</ul>
</li>
<li>缺页率
<ul>
<li>缺页率f = 缺页次数/ 访问页面总次数</li>
<li>命中率= 1 – f</li>
</ul>
</li>
<li>访存指令流程<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231228204824.png" alt="" loading="lazy"></li>
</ul>
<h4 id="淘汰策略">淘汰策略</h4>
<ul>
<li>选择淘汰哪一页的规则称淘汰策略。</li>
<li>页面抖动
<ul>
<li>页面在内存和辅存间频繁交换的现象</li>
<li>“抖动”会导致系统效率下降。</li>
</ul>
</li>
<li>好的淘汰策略
<ul>
<li>页面抖动较少</li>
<li>具有较低的缺页率（高命中率）</li>
</ul>
</li>
<li>最佳算法（OPT算法）
<ul>
<li>淘汰不再需要或最远将来才会用到的页面。</li>
<li>特点
<ul>
<li>理论上最佳，实践中该算法无法实现。</li>
</ul>
</li>
</ul>
</li>
<li>先进先出淘汰算法（FIFO算法）
<ul>
<li>淘汰在内存中停留时间最长的页面</li>
<li>优点：
<ul>
<li>实现简单：页面按进入内存的时间排序，淘汰队头页面。</li>
<li>进程按顺序访问地址空间时抖动较少，缺页率较低。</li>
</ul>
</li>
<li>异常现象
<ul>
<li>对于一些特定的访问序列，分配页框越多，缺页率越高</li>
</ul>
</li>
</ul>
</li>
<li>最久未使用淘汰算法（LRU算法）
<ul>
<li>淘汰最长时间未被使用的页面。</li>
<li>实现(硬件)
<ul>
<li>页面设置一个移位寄存器R，页面被访问则重置为1</li>
<li>周期性地(周期很短)将所有页面的R左移1位(右边为0)</li>
<li>当需要淘汰页面时选择R值最大的页</li>
<li>R的位数越多且移位周期越小就越精确，但硬件成本也越高。</li>
<li>若R的位数太少，可能同时出现多个为0页面情况，难以比较。</li>
</ul>
</li>
<li>软件实现
<ul>
<li>软件周期性（T）地将所有访问位置0</li>
<li>当淘汰页面时根据该页访问位来判断是否淘汰
<ul>
<li>访问位为1：不淘汰：在时间T内，该页被访问过。</li>
<li>访问位为0：可以淘汰：在时间T内，该页未被访问过！</li>
</ul>
</li>
</ul>
</li>
<li>缺点
<ul>
<li>周期T难定</li>
</ul>
</li>
</ul>
</li>
<li>最不经常使用（LFU）算法
<ul>
<li>选择到当前时间为止被访问次数最少的页面</li>
<li>每页设置<em>访问计数器</em>，每当页面被访问时，该页面的访问计数器加1；</li>
<li>发生缺页中断时，淘汰计数值最小的页面，<em>并将所有计数清零</em></li>
</ul>
</li>
</ul>
<h4 id="影响缺页次数的因素">影响缺页次数的因素</h4>
<ul>
<li>淘汰算法</li>
<li>分配给进程的页框数
<ul>
<li>页框越少，越容易缺页</li>
</ul>
</li>
<li>页本身大小
<ul>
<li>页面越小，容易缺页</li>
</ul>
</li>
<li>页面的大小选择
<ul>
<li>常见大小：2的整数次幂：1KB，2KB, 4KB</li>
<li>页面太大
<ul>
<li>页面增多，页表长度增加，浪费内存；</li>
</ul>
</li>
<li>页面太小
<ul>
<li>换页频繁，系统效率低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="快表机制cache">快表机制(cache)</h4>
<ul>
<li>分级存储体系
<ul>
<li>CACHE + 内存+ 辅存</li>
</ul>
</li>
<li>快表的特点
<ul>
<li>快表是普通页表（慢表）的部分内容的复制</li>
<li>地址映射时优先访问快表
<ul>
<li>若在快表中找到所需数据，则称为“命中”</li>
<li>没有命中时，需要访问慢表，同时更新快表</li>
</ul>
</li>
<li>合理的页面调度策略能使快表具有较高命中率</li>
</ul>
</li>
<li>地址映射过程<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231228212710.png" alt="" loading="lazy"></li>
</ul>
<h4 id="页面的共享">页面的共享</h4>
<ul>
<li>在页表中填上被共享代码（共享页框）的页框号。
<ul>
<li>共享代码/共享页框在内存只有一份存储。</li>
</ul>
</li>
</ul>
<h4 id="二级页表">二级页表</h4>
<ul>
<li>把页表(4MB)分拆成1K个小页表(4KB)且<em>分散</em>存放</li>
<li>为了对小页表进行管理和查找，另设置一个叫页目录的表，记录每个小页表的存放位置（即页框号）
<ul>
<li>页目录：1K条记录[小页表号: 页框号]，4KB</li>
<li>页目录：一级页表或外部页表</li>
<li>小页表：二级页表/页表</li>
</ul>
</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>页面划分无逻辑含义</li>
<li>页的共享不灵活</li>
<li>页内碎片</li>
</ul>
<h3 id="段式内存管理">段式内存管理</h3>
<h4 id="定义-7">定义</h4>
<ul>
<li>进程分段
<ul>
<li>把进程按逻辑意义划分为多个段，每段有段名，长度不定。进程由多段组成</li>
</ul>
</li>
<li>段式内存管理系统的内存分配
<ul>
<li>以段为单位装入，每段分配连续的内存；</li>
<li>段和段不要求相邻。</li>
</ul>
</li>
<li>段表
<ul>
<li>记录每段在内存中映射的位置</li>
<li>段号S ：段的编号（唯一的）</li>
<li>段长L ：该段的长度</li>
<li>基地址B ：段在内存中的地址</li>
</ul>
</li>
</ul>
<h4 id="映射机制">映射机制</h4>
<ul>
<li>虚拟地址
<ul>
<li>段式虚拟地址VA包含段号S和段内偏移W</li>
<li>VA:(S,W)</li>
</ul>
</li>
<li>映射过程
<ol>
<li>逻辑地址VA分离出(S, W);</li>
<li>以S为索引查询段表
<ul>
<li>检索段号S，查询该段基地址B和长度L</li>
</ul>
</li>
<li>物理地址MA＝ B+W</li>
</ol>
</li>
<li>段表的扩充
<ul>
<li>基本字段：段号，长度，基址</li>
<li>扩展字段：中断位，访问位，修改位，R/W/X</li>
</ul>
</li>
<li>段的共享
<ul>
<li>共享段在内存中只有一份存储</li>
<li>需要共享的模块都可以设置为单独的段</li>
<li>共享段写入相关进程的段表</li>
</ul>
</li>
<li>缺点：
<ul>
<li>段需要连续的存储空间</li>
<li>段的最大尺寸受到内存大小的限制</li>
<li>在辅存中管理可变尺寸的段比较困难</li>
</ul>
</li>
</ul>
<h3 id="段式系统vs-页式系统">段式系统vs 页式系统</h3>
<ul>
<li>地址空间的区别
<ul>
<li>页式系统：一维地址空间</li>
<li>段式系统：二维地址空间</li>
</ul>
</li>
<li>段与页的区别
<ul>
<li>段长可变vs 页面大小固定</li>
<li>段的划分有意义vs 页面无意义</li>
<li>段方便共享vs 页面不方便共享（相对）</li>
<li>段用户可见vs 页面用户不可见</li>
<li>段偏移有溢出vs 页面偏移无溢出</li>
</ul>
</li>
</ul>
<h3 id="段页式存储">段页式存储</h3>
<ul>
<li>在段式存储管理中结合页式存储管理技术</li>
<li>在段中划分页面</li>
</ul>
<h4 id="地址映射">地址映射</h4>
<ul>
<li>段号S、页号P和页内位移W</li>
<li><img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231229102138.png" alt="" loading="lazy"></li>
<li>段页式地址的映射机构
<ul>
<li>同时采用段表和页表实现地址映射
<ul>
<li>系统为每个进程建立一个段表</li>
<li>每个段建立一个页表</li>
</ul>
</li>
<li>段表给出每段的页表基地址及页表长度
<ul>
<li>页表给出段内每页对应的页框</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="linux存储管理">LINUX存储管理</h2>
<h4 id="实模式real-mode">实模式（Real Mode）</h4>
<ul>
<li>实模式阶段
<ul>
<li>计算机加电前一段时间处于实模式</li>
</ul>
</li>
<li>实模式寄存器
<ul>
<li>IP，AX，BX，CX，DX，SP，BP，SI，DI，FLAGS，CS，DS，SS，ES，FS，GS</li>
</ul>
</li>
<li>实模式内存空间
<ul>
<li>20位物理地址</li>
<li>1MB内存空间</li>
<li>分段机制：段地址(16位)：偏移地址(16位)</li>
</ul>
</li>
<li>实模式寻址
<ul>
<li>逻辑地址：段地址(16位) ：偏移地址(16位)</li>
<li>物理地址= 段地址左移4位+ 偏移地址</li>
</ul>
</li>
</ul>
<h4 id="保护模式">保护模式</h4>
<ul>
<li>保护模式寻址
<ul>
<li>段基址=段基址( DS )</li>
<li>全局描述符表/GDT
<ul>
<li>Global Descriptor Table</li>
<li>全局唯一一个，每个进程可见</li>
</ul>
</li>
<li>局部描述符表/LDT
<ul>
<li>Local Descriptor Table</li>
<li>每个进程/任务一个，表内含有进程的各种私有段的描述符。</li>
<li>LDT的描述符位于GDT中
<ul>
<li>LDT描述符</li>
</ul>
</li>
</ul>
</li>
<li>优化分段管理机制</li>
<li>支持分⻚管理机制</li>
<li>4GB内存空间（32位）</li>
</ul>
</li>
<li>CPU特性
<ul>
<li>支持多任务</li>
<li>支持特权级机制</li>
<li>扩展寄存器和新增寄存器
<ul>
<li>EAX~EDX，EIP，ESP，ESI，EDI，EFLAGS</li>
<li>CR0~CR4，GDTR，LDTR，IDTR，TR</li>
</ul>
</li>
<li>控制寄存器CR0
<ul>
<li>PE: 保护模式/实模式</li>
<li>MP: 有无数学协处理器</li>
<li>EM: 有无仿真协处理器</li>
<li>TS: 切换任务时自动设置</li>
<li>ET: 协处理器的类型</li>
<li>PG: 是否允许分页</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="描述符descriptor">描述符（Descriptor）</h4>
<ul>
<li>属性的描述
<ul>
<li>DPL:描述符特权级别Descriptor Privilege Level</li>
<li>P：Present，是否在内存中（1：在内存）</li>
<li>G：段的粒度（段长计量单位）
<ul>
<li>G=0, 字节(段最长1M)</li>
<li>G=1 ,页面4KB（段最长4G）</li>
</ul>
</li>
<li>S |TYPE：描述符的类型和特性<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231229103711.png" alt="" loading="lazy">
<ul>
<li>S=1（存储段）| S=0（系统段）</li>
<li>TYPE=4位
<ul>
<li>存取属性、特性类型</li>
<li>读，写，访问标志等</li>
</ul>
</li>
</ul>
</li>
<li>例子：quad 0x 00<em>C0 9A</em>80 0000 001F
<ul>
<li>结构<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231229104843.png" alt="" loading="lazy"><img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231229105323.png" alt="" loading="lazy"></li>
<li>G=1，P=1,DPL=00,S=1</li>
</ul>
</li>
</ul>
</li>
<li>描述符表（Descriptor Table）
<ul>
<li>存放描述符的数组/线性表</li>
<li>⻓度：8字节的整数倍。</li>
<li>分类
<ul>
<li>全局描述符表GDT</li>
<li>局部描述符表LDT</li>
<li>中断描述符表IDT</li>
</ul>
</li>
<li>选择子(Selector) /16位/段寄存器
<ul>
<li>用于选择GDT/LDT等表中的描述符</li>
<li>索引域（INDEX）
<ul>
<li>13位，描述符在描述符表中的序号<code>3-15</code></li>
</ul>
</li>
<li>表标识域（TI，Table Indicator）
<ul>
<li>1位：GDT(0)|LDT(1)<code>2</code></li>
</ul>
</li>
<li>请求特权级域（RPL）
<ul>
<li>2位，Request Privilege Level<code>0-1</code></li>
</ul>
</li>
<li>选择子放在段寄存器中</li>
</ul>
</li>
</ul>
</li>
<li>GDTR（48位）
<ul>
<li>GDT的基址（32位）</li>
<li>GDT的限长（16位）
<ul>
<li>GDT中描述符数量≤ 8k</li>
</ul>
</li>
<li>lgdtr:更新GDTR</li>
</ul>
</li>
<li>LDTR（16位）
<ul>
<li>选择子
<ul>
<li>选择GDT中的描述符/LDT描述符</li>
</ul>
</li>
<li>lldtr:更新LDT/进程切换</li>
</ul>
</li>
</ul>
<h4 id="保护模式内存寻址段式地址转换">保护模式内存寻址：段式地址转换</h4>
<ul>
<li>把逻辑地址转换到物理地址/线性地址<img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231229110112.png" alt="" loading="lazy"></li>
</ul>
<h2 id="设备管理概述">设备管理概述</h2>
<h3 id="类型和特征">类型和特征</h3>
<ul>
<li>按交互对象分类
<ul>
<li>人机交互：显示设备、键盘、鼠标、打印机</li>
<li>与CPU交互：磁盘、磁带、传感器、控制器</li>
<li>计算机间交互：网卡、调制解调器</li>
</ul>
</li>
<li>按交互方向分类
<ul>
<li>输入设备：键盘、扫描仪</li>
<li>输出设备：显示设备、打印机</li>
<li>双向设备：输入/输出：硬盘、软盘、网卡</li>
</ul>
</li>
<li>按外设特性分类
<ul>
<li>使用特征：存储设备、输入设备、输出设备</li>
<li>数据传输率：低速(键盘)、中速(打印机)、高速(网卡、磁盘)</li>
</ul>
</li>
<li>按信息组织特征分类
<ul>
<li>字符设备
<ul>
<li>传输的基本单位是字符。例：键盘、串口</li>
</ul>
</li>
<li>块设备
<ul>
<li>传输的基本单位是块。例：硬盘，磁盘</li>
</ul>
</li>
<li>网络设备
<ul>
<li>采用socket套接字接口访问</li>
<li>在全局空间有唯一名字，如eth0、eth1</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备管理功能">设备管理功能</h3>
<ul>
<li>目标：
<ul>
<li>1）提高设备读写效率
<ul>
<li>设备缓冲机制</li>
</ul>
</li>
<li>（2）提高设备的利用率
<ul>
<li>设备分配（设备调度）</li>
</ul>
</li>
<li>（3）为用户提供统一接口
<ul>
<li>实现设备对用户透明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="状态跟踪">状态跟踪</h4>
<ul>
<li>记录设备的基本属性、状态、操作接口及进程访问信息
<ul>
<li>设备控制块（Device Control Block，DCB)
<table>
<thead>
<tr>
<th>设备名</th>
</tr>
</thead>
<tbody>
<tr>
<td>设备属性</td>
</tr>
<tr>
<td>命令转换表</td>
</tr>
<tr>
<td>在I/O总线上的设备地址</td>
</tr>
<tr>
<td>设备状态</td>
</tr>
<tr>
<td>当前用户进程指针</td>
</tr>
<tr>
<td>I/O请求队列指针</td>
</tr>
</tbody>
</table>
</li>
<li>设备名
<ul>
<li>设备的物理名</li>
</ul>
</li>
<li>设备属性
<ul>
<li>设备当前状态（一组属性）</li>
</ul>
</li>
<li>命令转换表
<ul>
<li>设备操作接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="设备分配">设备分配</h4>
<ul>
<li>按一定策略安全地分配和管理各种设备。
<ul>
<li>按相应算法把设备分配给请求该设备的进程，并把未分到设备的进程放入设备等待队列。</li>
</ul>
</li>
</ul>
<h4 id="设备映射">设备映射</h4>
<ul>
<li>设备逻辑名/友好名(Friendly Name)
<ul>
<li>用户编程时使用的名字（文件名/设备文件名）</li>
<li>例：Linux： /dev/test</li>
</ul>
</li>
<li>设备独立性/设备无关性
<ul>
<li>用户程序中使用统一接口访问逻辑设备，而不用考虑对应物理设备的特殊结构和操作方式。</li>
</ul>
</li>
</ul>
<h4 id="io缓冲区管理">I/O缓冲区管理</h4>
<ul>
<li>开辟和管理I/O缓冲区</li>
<li>提高读写效率</li>
</ul>
<h4 id="设备控制设备驱动">设备控制/设备驱动</h4>
<ul>
<li>对物理设备进行I/O操作（IN/OUT指令）</li>
<li>把应用对设备的读/写请求转换为对设备I/O操作。</li>
<li>应用读写请求采用文件接口
<ul>
<li>open/read/write/close</li>
<li>设备是文件</li>
</ul>
</li>
<li>设备驱动程序的特点
<ul>
<li>设备驱动程序与硬件密切相关。</li>
<li>设备必须要配置驱动程序</li>
<li>动程序一般由设备厂商根据操作系统要求编写</li>
</ul>
</li>
</ul>
<h2 id="缓冲技术">缓冲技术</h2>
<h3 id="缓冲作用">缓冲作用</h3>
<ol>
<li>连接不同数据传输速度的设备
<ul>
<li>CPU（设备驱动）与设备（控制器）之间传输数据</li>
<li>内存中增加缓冲区</li>
</ul>
</li>
<li>协调数据记录大小的不一致
<ul>
<li>进程之间或CPU与设备之间的数据记录大小不一致</li>
<li>进程（结构）：设备（字节）</li>
</ul>
</li>
<li>正确执行应用程序的语义拷贝
<ul>
<li>利用write( Data, Len)向磁盘写入数据Data</li>
<li>方法1：应用等待内核写完磁盘再返回(实时性差)</li>
<li>方法2：应用仅等内核写完内存即返回
<ul>
<li>事后由内核把缓冲区写到磁盘。(实时性好)</li>
</ul>
</li>
<li>语义拷贝：确保事后拷贝的数据是正确版本</li>
</ul>
</li>
</ol>
<h3 id="linux缓冲机制应用">Linux缓冲机制应用</h3>
<h4 id="典型的块设备">典型的块设备</h4>
<ul>
<li>硬盘、软盘、RAM DISK等</li>
<li>块(block)和扇区
<ul>
<li>硬盘读/写/寻址：扇区</li>
<li>文件读/写/寻址：块
<ul>
<li>块= 2n ×扇区</li>
<li>Linux块= 1KB (n=1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="linux缓冲机制">Linux缓冲机制</h4>
<ul>
<li>内存开辟高速缓冲区</li>
<li>提前读
<ul>
<li>进程读时，其所需数据已被提前读到了缓冲区中，不需要启动外设去执行读操作。</li>
</ul>
</li>
<li>延后写
<ul>
<li>进程写时，数据先存在缓冲区，等到特定事件发生或足够时间后（已延迟），再启动外设完成写入。</li>
</ul>
</li>
<li>目的：
<ul>
<li>提高进程与外设数据传输效</li>
<li>减少访问设备次数，提高设备访问的效率。</li>
<li>内存开辟高速缓冲区</li>
</ul>
</li>
<li>高速缓冲区(内存区)
<ul>
<li>按块分为缓冲块(数据块)，与磁盘块对应</li>
<li>缓冲头（buffer_head）：描述缓冲块</li>
</ul>
<pre><code class="language-C++">struct buffer_head{
char* b_data//指向缓冲块对应的数据区
unsigned long b_blocknr//设备中的块号
unsigned short b_dev//设备号
unsigned char b_lock//表示该缓冲块是否已被锁定
unsigned char b_count//缓冲块被多少个进程引用
unsigned char b_dirt//延迟写字段，即脏位字段
unsigned char b_uptodate//数据有效位字段
struct task_struct* b_wait//指向访问缓冲块的等待队列
}
</code></pre>
</li>
<li>进程读写设备数据
<ul>
<li>进程read/write →文件访问请求→ 块读取bread( )</li>
</ul>
</li>
<li>块读取函数bread(设备号,块号)
<ul>
<li>以(设备号, 块号)为索引搜索高速缓冲区，查找对应的缓冲块
<ul>
<li>若找到，直接读回</li>
<li>若没有找到
<ul>
<li>分配一个新缓冲块</li>
<li>调用ll_rw_block( )读相应磁盘块到新分配的缓冲块</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="组成">组成</h4>
<ul>
<li>Cache
<ul>
<li>高速缓冲寄存器【CPU ↔ 内存】</li>
</ul>
</li>
<li>设备内部缓冲区
<ul>
<li>外设或I/O接口的内部缓冲区【端口】</li>
</ul>
</li>
<li>内存缓冲区
<ul>
<li>应用广泛，使用灵活【CPU ↔ 接口/外设】</li>
<li>应用开辟| 内核开辟</li>
</ul>
</li>
<li>辅存缓冲区
<ul>
<li>开辟在辅存上【暂存内存数据，SWAP】</li>
</ul>
</li>
</ul>
<h4 id="实现">实现</h4>
<ul>
<li>单缓冲
<ul>
<li>缓冲区仅有1个单元</li>
</ul>
</li>
<li>双缓冲
<ul>
<li>缓冲区有2个单元</li>
</ul>
</li>
<li>环形缓冲
<ul>
<li>在双缓冲的基础上增加了更多的单元，并让首尾两个单元在逻辑上相连</li>
<li>pStart起始指针</li>
<li>pWrite输入指针</li>
<li>pRead输出指针</li>
</ul>
</li>
<li>缓冲池
<ul>
<li>多个缓冲区</li>
<li>可供若干个进程共享</li>
<li>可以支持输入，也可以支持输出</li>
<li>提高缓冲区利用率，减少内存浪费</li>
</ul>
</li>
</ul>
<h2 id="设备驱动程序">设备驱动程序</h2>
<ul>
<li>定义设备操作接口与文件操作接口之间的映射</li>
<li>实现设备的注册函数和注销函数</li>
<li>设备注册
<ul>
<li>将用户定义的设备加入到系统的设备数组</li>
</ul>
</li>
<li>设备注销
<ul>
<li>释放设备，将设备从系统的设备数组删除</li>
</ul>
</li>
<li>编译驱动程序</li>
<li>安装/删除驱动程序<pre><code>insmod RWDevState.ko
rmmod RWDevState
</code></pre>
</li>
<li>创建设备文件</li>
</ul>
<h3 id="驱动程序在系统中的地位">驱动程序在系统中的地位</h3>
<h4 id="面向用户程序的接口">面向用户程序的接口</h4>
<ul>
<li>设备的打开与释放</li>
<li>设备的读写操作</li>
<li>设备的控制操作</li>
<li>设备的中断处理</li>
<li>设备的轮询处理</li>
</ul>
<h4 id="面向io管理器的接口">面向I/O管理器的接口</h4>
<ul>
<li>注册函数
<ul>
<li>insmod(命令)
<ul>
<li>module_init() (API)</li>
</ul>
</li>
</ul>
</li>
<li>注销函数
<ul>
<li>rmmod (命令)
<ul>
<li>module_exit() (API)</li>
</ul>
</li>
</ul>
</li>
<li>必需的数据结构</li>
</ul>
<h4 id="面向设备的接口">面向设备的接口</h4>
<ul>
<li>实现设备的端口操作
<ul>
<li>无条件传送</li>
<li>查询传送</li>
<li>中断传送</li>
<li>DMA传送</li>
</ul>
</li>
</ul>
<h4 id="驱动程序工作在核态">驱动程序工作在核态</h4>
<ul>
<li>驱动程序工作在内核态</li>
<li>应用程序和驱动程序之间传送数据
<ul>
<li>get_user( )</li>
<li>put_user( )</li>
<li>copy_from_user ( )</li>
<li>copy_to_user ( )</li>
</ul>
</li>
</ul>
<h4 id="设备文件">设备文件</h4>
<ul>
<li>主设备号
<ul>
<li>标识该设备种类，标识驱动程序</li>
<li>主设备号的范围：1-255</li>
<li>Linux内核支持动态分配主设备号</li>
</ul>
</li>
<li>次设备号
<ul>
<li>标识同一设备驱动程序的不同硬件设备</li>
</ul>
</li>
</ul>
<h2 id="设备分配-2">设备分配</h2>
<h3 id="设备分类">设备分类</h3>
<h4 id="独占设备">独占设备</h4>
<ul>
<li>不可抢占设备（普通外设或资源）
<ul>
<li>使用时抢占，释放后才能被其他进程申请到</li>
<li>先申请，后使用（主动）</li>
</ul>
</li>
</ul>
<h4 id="共享设备">共享设备</h4>
<ul>
<li>可抢占设备（CPU，内存，硬盘）
<ul>
<li>允许多个作业或进程同时使用。</li>
<li>不申请，直接用（被动+ 主动）</li>
</ul>
</li>
</ul>
<h4 id="虚拟设备">虚拟设备</h4>
<ul>
<li>借助虚拟技术，在共享设备上模拟独占设备。</li>
</ul>
<h3 id="分配方法">分配方法</h3>
<h4 id="独享分配">独享分配</h4>
<ul>
<li>针对独占设备</li>
<li>流程：申请→占用→释放
<ul>
<li>指进程使用设备之前先申请，申请成功开始使用，直到使用完再释放。</li>
</ul>
</li>
<li>若设备已经被占用，则进程会被阻塞，被挂入设备对应的等待队列等待设备可用之时被唤醒。</li>
</ul>
<h4 id="共享分配">共享分配</h4>
<ul>
<li>针对共享设备
<ul>
<li>典型共享设备：硬盘</li>
</ul>
</li>
<li>当进程申请使用共享设备时，操作系统能立即为其分配共享设备的一块空间（空分方式），不让进程产生阻塞。</li>
<li>共享分配随时申请，随时可得。</li>
</ul>
<h4 id="虚拟分配">虚拟分配</h4>
<ul>
<li>虚拟技术
<ul>
<li>在一类物理设备上模拟另一类物理设备的技术</li>
<li>通常借助辅存部分区域模拟独占设备，将独占设备转化为共享设备。</li>
</ul>
</li>
<li>虚拟设备
<ul>
<li>用来模拟独占设备的<em>辅存区域</em>称为虚拟设备
<ul>
<li>具有独占设备的逻辑特点</li>
</ul>
</li>
<li>输入井：模拟输入设备的辅存区域</li>
<li>输出井：模拟输出设备的辅存区域</li>
</ul>
</li>
<li>当进程申请独占设备时将对应虚拟设备分配给它
<ul>
<li>首先，采用共享分配为进程分配虚拟设备</li>
<li>其次，将虚拟设备与对应的独占设备关联</li>
<li>进程运行中仅与虚拟设备交互，提高了运行效率</li>
</ul>
</li>
</ul>
<h2 id="spool技术">SPOOL技术</h2>
<h3 id="结构硬件">结构（硬件）</h3>
<figure data-type="image" tabindex="2"><img src="file:///D:%5Cnextcloud%5Cmoyi%5C%E6%88%AA%E5%9B%BE%5CPasted%20image%2020231229133734.png" alt="" loading="lazy"></figure>
<h4 id="输入和输出井">输入和输出井</h4>
<ul>
<li>磁盘上开辟出来的两个存储区域
<ul>
<li>输入井模拟脱机输入时的磁盘</li>
<li>输出井模拟脱机输出时的磁盘</li>
</ul>
</li>
</ul>
<h4 id="输入缓冲区和输出缓冲区">输入缓冲区和输出缓冲区</h4>
<ul>
<li>内存中开辟的存储区域
<ul>
<li>输入缓冲区：暂存输入数据，以后再传送到输入井。</li>
<li>输出缓冲区：暂存输出数据，以后再传送到输出设备。</li>
</ul>
</li>
</ul>
<h4 id="预输入程序">预输入程序</h4>
<ul>
<li>控制信息从独占设备输入到辅存，模拟脱机输入的卫星机</li>
</ul>
<h4 id="输入表">输入表</h4>
<ul>
<li>独占设备↔虚拟设备</li>
</ul>
<h4 id="缓输出程序">缓输出程序</h4>
<ul>
<li>控制信息从辅存输出到独占设备，模拟脱机输出的卫星机；</li>
</ul>
<h4 id="输出表">输出表</h4>
<ul>
<li>独占设备↔虚拟设备</li>
</ul>
<h4 id="井管理程序">井管理程序</h4>
<ul>
<li>控制用户程序和辅存之间的信息交换</li>
</ul>
<h3 id="优点">优点</h3>
<ul>
<li>“提高”了I/O速度</li>
<li>将独占设备改造为“共享”设备
<ul>
<li>实现了虚拟设备功能</li>
</ul>
</li>
</ul>
<h2 id="文件和文件系统概念">文件和文件系统概念</h2>
<h3 id="文件">文件</h3>
<ul>
<li>文件是计算机系统存放信息的一种形式，由若干信息项有序构成。</li>
<li>文件具有唯一的文件名。</li>
<li>用户通过读写指针来存取文件的信息项。</li>
</ul>
<h3 id="文件的分类">文件的分类</h3>
<ul>
<li>按文件的用途
<ul>
<li>系统文件</li>
<li>库文件</li>
<li>用户文件</li>
</ul>
</li>
<li>按文件的操作权限
<ul>
<li>只读文件</li>
<li>只写文件</li>
<li>可执行文件</li>
<li>可读可写文件</li>
<li>不保护文件</li>
</ul>
</li>
<li>按文件的存储时间
<ul>
<li>永久文件</li>
<li>临时文件</li>
</ul>
</li>
<li>按文件的性质
<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>设备文件</li>
</ul>
</li>
</ul>
<h3 id="文件系统">文件系统</h3>
<ul>
<li>管理文件的机构
<ul>
<li>实现文件的创建、撤消、读写、修改、复制和存取控制等
<ul>
<li>方便用户以<em>文件名</em>存取文件</li>
</ul>
</li>
<li>管理文件<em>存储设备</em>的空间和存取
<ul>
<li>高效利用存储空间和高效存取文件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件结构">文件结构</h2>
<h3 id="文件的逻辑结构">文件的逻辑结构</h3>
<h4 id="记录式文件">记录式文件</h4>
<ul>
<li>信息项是记录，记录包含若干成员</li>
<li>特点：
<ul>
<li>文件头部保存记录长和记录数信息</li>
<li>浪费存储空间</li>
</ul>
</li>
<li>分类
<ul>
<li>定长记录文件</li>
<li>不定长记录文件</li>
</ul>
</li>
</ul>
<h4 id="流式文件">流式文件</h4>
<ul>
<li>信息项是字节</li>
<li>特点
<ul>
<li>文件长度就是字节的数量</li>
<li>文件无需额外说明信息或控制信息</li>
</ul>
</li>
<li>现代OS把文件当作流式文件，由应用解释</li>
</ul>
<h3 id="文件的存取方法">文件的存取方法</h3>
<ul>
<li>顺序存取
<ul>
<li>按从前往后的顺序对文件信息项进行读/写直到定位到目标信息项为止</li>
</ul>
</li>
<li>随机存储/直接访问
<ul>
<li>直接定位到文件目标信息项进行读写</li>
<li>适合流式文件或定长记录文件</li>
</ul>
</li>
</ul>
<h3 id="文件的物理结构">文件的物理结构</h3>
<ul>
<li>文件在存储设备上的存储结构</li>
<li>签掉合理利用储存空间，缩短I/O时间</li>
<li>类型
<ul>
<li>连续文件
<ul>
<li>连续文件指文件存放在连续的存储块中。</li>
</ul>
</li>
<li>串联文件
<ul>
<li>串联文件存放在离散的存储块中，每个存储块包含一个链接指针记录下一个存储块位置。</li>
<li>例子：FAT文件系统
<ul>
<li>File Allocation Table，FAT，文件分配表</li>
<li>文件分配表是一维数组，与存储设备空间对应，元素与存储块一一有序对应，每个元素存放文件下一个逻辑块所在存储块的块号。</li>
<li>FAT16文件系统</li>
<li>存储块（簇） = 64个扇区</li>
<li>FAT元素16位宽,存储块(簇)数 ≤ 216簇</li>
<li>磁盘容量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><msup><mn>2</mn><mn>16</mn></msup><mi mathvariant="normal">簇</mi><mo>∗</mo><mn>64</mn><mi mathvariant="normal">扇</mi><mi mathvariant="normal">区</mi><mo>∗</mo><mn>512</mn><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mo>=</mo><mn>2</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">\le2^{16}簇* 64扇区* 512字节= 2GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">簇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord cjk_fallback">扇</span><span class="mord cjk_fallback">区</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>索引文件
<ul>
<li>读取索引文件时应先读取索引表</li>
<li>索引表本身占据额外的存储区域/缺点</li>
<li>支持顺序和随机存取</li>
<li>支持文件动态增长、插入、删除等</li>
<li>实例：ext系列文件系统(inode索引节点文件)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存储空间管理">存储空间管理</h2>
<h3 id="磁盘存储空间管理">磁盘存储空间管理</h3>
<ul>
<li>管理和记录磁盘空间使用情况。</li>
</ul>
<h4 id="空闲文件目录">空闲文件目录</h4>
<ul>
<li>空闲文件：连续的空闲存储块组成的特殊文件。
<ul>
<li>存储设备上所有的空闲文件就代表了存储设备上的全部空闲空间。</li>
</ul>
</li>
<li>空闲文件目录：为所有空闲文件建立的目录
<ul>
<li>记录空闲文件的首块号和存储块数(或其他方式)</li>
</ul>
</li>
</ul>
<h4 id="空闲块链">空闲块链</h4>
<ul>
<li>把所有空闲存储块用链表链接在一起。
<ul>
<li>当申请空闲块时，从链表头部摘取空闲块</li>
<li>当回收存储块时，把空闲块加在链表尾部。</li>
</ul>
</li>
</ul>
<h4 id="位示图">位示图</h4>
<ul>
<li>一块特殊内存区域，每一位(bit)对应一个存储块，值1表示存储块空闲，0表示已占用。</li>
</ul>
<h3 id="文件目录">文件目录</h3>
<ul>
<li>功能
<ul>
<li>实现“按名存取”：系统根据文件名能找到指定文件。
<ul>
<li>文件目录记录文件的文件名、存放地址以及属性</li>
</ul>
</li>
</ul>
</li>
<li>目录文件
<ul>
<li>目录文件是文件目录的实现，由文件目录项构成</li>
</ul>
</li>
<li>文件目录项
<ul>
<li>描述文件基本信息、使用信息和存取控制信息等。
<ul>
<li>基本信息：文件名、存储位置(存储块号)等</li>
<li>使用信息：属性、大小、建立时间、修改时间等</li>
<li>存取控制信息：文件存取权限</li>
</ul>
</li>
</ul>
</li>
<li>目录结构
<ul>
<li>单级目录
<ul>
<li>最简单的目录结构，全部文件都登记在同一目录中。</li>
<li>简单、易于理解和实现</li>
<li>缺点
<ul>
<li>查找速度慢| 不允许重名| 不便于文件共享</li>
</ul>
</li>
</ul>
</li>
<li>二级目录
<ul>
<li>第一级称为主目录(MFD)，第二级称为子目录或用户目(UFD)。
<ul>
<li>每个用户有一个子目录(用户目录)</li>
</ul>
</li>
<li>解决文件重名的问题，不同用户可以使用相同名字。</li>
</ul>
</li>
<li>树状目录
<ul>
<li>多级目录结构，二级目录结构的扩充</li>
<li>目录结构如同倒置的树，树根是主目录(根目录)，枝结点是子目录，树叶描述文件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文件全名">文件全名</h3>
<ul>
<li>从根目录到文件为止整个通路上所有目录、子目录和文件的名字用”/”顺序连接构成的字符串称为文件全名。
<ul>
<li>路径名：文件全名中由目录和子目录组成的部分。
<ul>
<li>每个文件都有惟一的路径名。</li>
</ul>
</li>
<li>路径名的表达形式
<ul>
<li>绝对路径名：从根目录直到文件的路径</li>
<li>相对路径名：从指定目录到文件的路径</li>
</ul>
</li>
</ul>
</li>
<li>文件属性
<ul>
<li>相对路径名：从指定目录到文件的路径</li>
<li>文件的属性一般存放在文件的（目录/文件 ）中。</li>
</ul>
</li>
<li>文件操作
<ul>
<li>创建文件</li>
<li>写文件</li>
<li>读文件</li>
<li>文件定位</li>
<li>删除文件</li>
<li>截短文件</li>
<li>属性设置和读取</li>
</ul>
</li>
<li>目录操作
<ul>
<li>创建目录</li>
<li>删除目录<br>
1,鸿蒙OS的技术架构分为内核层、系统服务层、框架层、应用层(√)<br>
2,鸿蒙OS的技术特点为分布式软总线、分布式设备虚拟化、分布式数据管理、分布式任务调度、一次开发，多终端部署、系统统一，弹性部署(×)<br>
3、鸿蒙OS技术架构从上往下分别为（A ）<br>
A、应用层系统服务层框架层内核层<br>
B、应用层框架层系统服务层应用层<br>
C、系统服务层框架层应用层内核层<br>
D、框架层内核层系统服务层应用层<br>
4、鸿蒙OS具备（C）三大核心能力<br>
A、分布式软总线、分布式设备虚拟化、分布式数据管理<br>
B、分布式设备虚拟化、分布式数据管理、分布式任务调度<br>
C、分布式软总线、分布式数据管理、分布式安全<br>
D、分布式设备虚拟化、分布式数据管理、分布式安全<br>
5、鸿蒙OS系统功能设计按照下列（C ）顺序从整体到局部逐级展开。<br>
A.系统-&gt; 功能-&gt; 子系统-&gt; 模块B.模块-&gt; 功能-&gt; 子系统-&gt; 系统<br>
C.系统-&gt; 子系统-&gt; 功能-&gt; 模块D.模块-&gt; 子系统-&gt; 功能-&gt; 系统<br>
6，BUILD.gn文件中sources = [ &quot;LED.c&quot;, ] 表明编译生成静态库的源代码文件来源于LED.c （√ ）<br>
7、vscode与Ubuntu通过命令（C）bossay@ip -A链接<br>
A、scp B、vim C、ssh D、snp<br>
8、程序编译完成后烧录到开发板中的文件存在于（B）文件中<br>
A、device B、out C、build D、vendor<br>
9、程序通过串口烧录到开发板中时，不需要选择auto burn选项（×）<br>
10、烧录完成后、将Disconect切换成Connect就按下复位键运行程序的话、会导致程序重新烧录（√）</li>
</ul>
</li>
</ul>
<blockquote>
<p>（1）已发群中“鸿蒙专题复习.pdf”要复习，是考试内容之一。<br>
（2）进程调度算法，尤其是Linux进程调度基本原理（优先数调度）要搞懂，这是典型的调度算法，也是课程设计的内容。<br>
（3）内存管理：理解分页存储管理和分段存储管理的地址映射的过程，这两种机制都不要求内存连续分配，理解这两种机制下程序装入，内存分配，地址映射的全过程。<br>
（4）有/无快表时页式地址的映射机制，快表命中率80%，90%的含义，看课堂上PPT上的习题。<br>
（5）P-V操作：<br>
同步问题：识别哪些是“关键操作”，“有条件执行的操作”，“影响其他操作的操作”，P-V操作添加的位置：关键操作之前还是之后；<br>
互斥问题：临界区/临界资源的访问<br>
（6）设备管理和文件管理二章：简答题会多些，主要是概念为主。</p>
</blockquote>
<ol>
<li>计算机通过硬件中断机制完成由用户态到核态的转换</li>
<li>程序设计中无法实现屏蔽中断</li>
<li>”访管“指令仅能在用户态下使用</li>
<li>广义指令即系统调用</li>
<li>trap指令负责由用户态转换成核态</li>
<li>内部中断类似整数除0，无法通过异常处理程序恢复，无法回到原来中断处</li>
<li>PC值由中断指令隐程序自动保存，通用寄存器由操作系统保存</li>
<li>区分核态与用户态是为了保护操作系统</li>
<li>用户通过内部中断进入内核态，</li>
<li>MBR大小是512B</li>
<li>段式系统共享比页式共享方便</li>
<li>在分区管理下，导致碎片的原因是作业连续存储</li>
<li>进程是资源分配的基本单位（不管有没有线程），没线程，进程是CPU调度的基本单位，有线程，线程是CPU调度的基本单位</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代码随想录day13-二叉树]]></title>
        <id>https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day13-er-cha-shu/</id>
        <link href="https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day13-er-cha-shu/">
        </link>
        <updated>2023-10-24T02:26:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="二叉树">二叉树</h2>
<h3 id="概述">概述</h3>
<ul>
<li>满二叉树
<ul>
<li>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</li>
<li>深度为k，有2^k-1个节点的二叉树。</li>
</ul>
</li>
<li>完全二叉树
<ul>
<li>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</li>
<li><strong>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系</strong></li>
</ul>
</li>
<li>二叉搜索树
<ul>
<li>二叉搜索树是有数值的了，二叉搜索树是一个有序树。</li>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
</li>
<li>平衡二叉搜索树
<ul>
<li>又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li>
<li>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>存储方式
<ul>
<li>二叉树可以链式存储，也可以顺序存储。</li>
<li>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</li>
<li>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</li>
<li>用数组来存储二叉树如何遍历的呢？</li>
<li>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</li>
</ul>
</li>
<li>二叉树的遍历方式
<ul>
<li>这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候 还会介绍到。</li>
<li>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</li>
<li>深度优先遍历
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
</li>
<li>二叉树的定义</li>
</ul>
<pre><code class="language-C++">struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre>
<h3 id="递归遍历">递归遍历</h3>
<p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">前序遍历</a><br>
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* node,vector&lt;int&gt; &amp;t)
    {
        if(node==nullptr)
        return;
        else
        t.push_back(node-&gt;val);
        traversal(node-&gt;left,t);
        traversal(node-&gt;right,t);

    }
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        vector&lt;int&gt; result;
        traversal(root,result);
        return result;
    }
};
</code></pre>
<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">中序遍历</a><br>
给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p>
<pre><code class="language-C++">class Solution {
public:
    void traversal(TreeNode* node,vector&lt;int&gt; &amp;t)
    {
        if(node==nullptr)
        return;
        traversal(node-&gt;left,t);
        t.push_back(node-&gt;val);
        traversal(node-&gt;right,t);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt;ans;
        traversal(root,ans);
        return ans;
    }
};
</code></pre>
<p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">后序编历</a><br>
给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p>
<pre><code class="language-C++">class Solution {
public:
    void traversal(TreeNode* node,vector&lt;int&gt; &amp;t)
    {
        if(node==nullptr)
        return;
        traversal(node-&gt;left,t);
        traversal(node-&gt;right,t);
        t.push_back(node-&gt;val);
    }
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        vector&lt;int&gt; ans;
        traversal(root,ans);
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代码随想录day12-栈与队列2]]></title>
        <id>https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day11-zhan-yu-dui-lie-2/</id>
        <link href="https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day11-zhan-yu-dui-lie-2/">
        </link>
        <updated>2023-10-21T12:08:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="栈与队列2">栈与队列2</h2>
<h3 id="有效的括号"><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h3>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>
左括号必须以正确的顺序闭合。<br>
每个右括号都有一个对应的相同类型的左括号。</p>
<p>思路：</p>
<ol>
<li>遇到左符号就压入栈，遇到右符号就和栈顶匹配，如果匹配就出栈，到最后如果栈非空就错误。</li>
</ol>
<pre><code class="language-C++">class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; stc;
        for(char node:s)
        {
            if(node=='('||node=='['||node=='{')
            {
                stc.push(node);
            }
            if(node==']'||node=='}')
            {
                if(stc.empty()||stc.top()!=node-2)
                {
                    return false;
                }
                else
                {
                    stc.pop();
                }
            }
            if(node==')')
            {
                if(stc.empty()||stc.top()!=node-1)
                {
                    return false;
                }
                else
                {
                    stc.pop();
                }
            }
        }
        if(stc.empty())
        return true;
        else return false;
    }
};
</code></pre>
<ol start="2">
<li>遇到左边符号就把右边符号压入栈，遇到右符号就和栈匹配</li>
</ol>
<pre><code class="language-C++">class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt; stc;
        for(char node:s)
        {
            if(node=='('){stc.push(')');}
            else if(node=='['){stc.push(']');}
            else if(node=='{'){stc.push('}');}
            else {
                if(stc.empty()||node!=stc.top())return false;
                else stc.pop();
            }
        }
        if(stc.empty())
        return true;
        else return false;
    }
};
</code></pre>
<h3 id="删除字符串中的所有相邻重复项"><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></h3>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>
在 S 上反复执行重复项删除操作，直到无法继续删除。<br>
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一</p>
<p>思路：<br>
读入一个字符，与栈顶匹配，匹配就pop,不匹配就压入栈，最后再反转得到结果</p>
<pre><code class="language-C++">class Solution {
public:
    string removeDuplicates(string s) {
        stack&lt;char&gt; cp;
        string ans;
        for(char node:s)
        {
            if(!cp.empty()&amp;&amp;node==cp.top())
            {
                cp.pop();
            }
            else
            {
                cp.push(node);
            }
        }
        while(!cp.empty())
        {
            ans+=cp.top();
            cp.pop();
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
</code></pre>
<h3 id="逆波兰表达式"><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">逆波兰表达式</a></h3>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<p>有效的算符为 '+'、'-'、'*' 和 '/' 。<br>
每个操作数（运算对象）都可以是一个整数或者另一个表达式。<br>
两个整数之间的除法总是 向零截断 。<br>
表达式中不含除零运算。<br>
输入是一个根据逆波兰表示法表示的算术表达式。<br>
答案及所有中间计算结果可以用 32 位 整数表示。<br>
思路：<br>
用栈存数字，当读入操作符的时候，pop出两个数进行计算，并push回去</p>
<pre><code class="language-C++">class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        stack&lt;int&gt; cp;
        for(string node:tokens)
        {
            if(node.length()&gt;1||(node.length()==1&amp;&amp;node[0]&lt;='9'&amp;&amp;node[0]&gt;='0'))
            {
                int t=stoi(node);
                cp.push(t);
            }
            else
            {
                int n2=cp.top();
                cp.pop();
                int n1=cp.top();
                cp.pop();
                int ans;
                switch(node[0]){
                    case '+':ans=n1+n2;break;
                    case '-':ans=n1-n2;break;
                    case '*':ans=n1*n2;break;
                    case '/':ans=n1/n2;break;
                }
                cp.push(ans);
            }
        }
        return cp.top();
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[视觉组工作]]></title>
        <id>https://moyihust.github.io/post/shi-jue-zu-gong-zuo/</id>
        <link href="https://moyihust.github.io/post/shi-jue-zu-gong-zuo/">
        </link>
        <updated>2023-10-21T11:20:05.000Z</updated>
        <content type="html"><![CDATA[<p>负责活动的直播和录像<br>
设备需求：<br>
1.相机，usb线/采集卡，电脑，麦克风（最好有），三脚架<br>
2.或者手机，需要一个直播一个录像<br>
操作流程</p>
<ol>
<li>相机通过线连接到电脑</li>
<li>使用自己的b站账号</li>
<li>obs设置好推往自己的账号</li>
<li>启动直播</li>
<li>将直播间分享到大群，以及用官方账号发动态</li>
<li>记得保持电量</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汇编]]></title>
        <id>https://moyihust.github.io/post/hui-bian/</id>
        <link href="https://moyihust.github.io/post/hui-bian/">
        </link>
        <updated>2023-10-20T09:37:59.000Z</updated>
        <content type="html"><![CDATA[<h1 id="汇编">汇编</h1>
<h2 id="汇编语言基础">汇编语言基础</h2>
<h3 id="微型计算机系统">微型计算机系统</h3>
<ul>
<li>主存空间的分配
<ul>
<li>
<p>8086CPU地址线是20位，最大寻址空间为 1MB，范围是00000H~FFFFFH,分为4个区段</p>
<ul>
<li>
<p>基本RAM区(00000H~9FFFFH )</p>
<ul>
<li>640KB，由DOS管理，操作系统占用一部分低地址空间，剩下开放给用户程序</li>
</ul>
</li>
<li>
<p>保留RAM区(A0000H~BFFFFH)</p>
<ul>
<li>128KB，给系统安排的显示缓冲存储区，由显卡RAM芯片提供，用于存放屏幕显示信息，没有全部使用</li>
</ul>
</li>
<li>
<p>拓展ROM(C0000H~DFFFFH)</p>
<ul>
<li>128KB,由I/O接口卡的ROM芯片支持，给外设安排驱动程序</li>
</ul>
</li>
<li>
<p>系统ROM区(E0000H~FFFFFH)</p>
<ul>
<li>128KB,系统占用，提供BIOS(基本输入输出程序)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8086微处理器">8086微处理器</h3>
<ul>
<li>
<p>8086的结构功能</p>
<ul>
<li>
<p>内部结构</p>
</li>
<li>
<p>结构功能</p>
<ul>
<li>
<p>右半部分</p>
<ul>
<li>
<p>总线接口单元BIU</p>
</li>
<li>
<p>构成</p>
<ul>
<li>
<p>6字节的指令队列</p>
</li>
<li>
<p>指令指针</p>
</li>
<li>
<p>段寄存器</p>
<ul>
<li>
<p>CS</p>
<ul>
<li>代码段寄存器</li>
</ul>
</li>
<li>
<p>DS</p>
</li>
<li>
<p>SS</p>
</li>
<li>
<p>ES</p>
</li>
</ul>
</li>
<li>
<p>地址加法器</p>
</li>
<li>
<p>总线控制逻辑</p>
</li>
</ul>
</li>
<li>
<p>功能</p>
<ul>
<li>管理8086与外部总线的接口</li>
<li>负责CPU对存储器和外设的访问</li>
</ul>
</li>
</ul>
</li>
<li>
<p>左半部分</p>
<ul>
<li>
<p>执行单元EU</p>
</li>
<li>
<p>构成</p>
<ul>
<li>
<p>算术逻辑单元ALU</p>
</li>
<li>
<p>数据寄存器</p>
<ul>
<li>存放数据</li>
</ul>
</li>
<li>
<p>地址寄存器</p>
<ul>
<li>存放地址</li>
</ul>
</li>
<li>
<p>标志寄存器</p>
</li>
<li>
<p>指令译码的EU控制逻辑</p>
</li>
</ul>
</li>
<li>
<p>功能</p>
<ul>
<li>指令的译码执行</li>
<li>数据的运算</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>完成一条指令的过程</p>
<ul>
<li>
<p>取指</p>
<ul>
<li>
<p>从主存储器中取出指令代码进入CPU</p>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>提供指令地址</p>
<ul>
<li>由代码段寄存器CS和指令指针寄存器IP共同提供，由地址加法器得到20位存储器地址</li>
</ul>
</li>
<li>
<p>取出指令代码</p>
<ul>
<li>由总线接口单元BIU从存储器取出指令代码，送入指令队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行</p>
<ul>
<li>
<p>将指令代码翻译成它代表的功能，即译码</p>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>取出指令代码</p>
</li>
<li>
<p>译码发出控制型号</p>
</li>
<li>
<p>进行数据运算和数据传送</p>
<ul>
<li>算术逻辑单元</li>
</ul>
</li>
<li>
<p>操作数据来源</p>
<ul>
<li>CPU内部寄存器，指令队列，存储器和外设（由EU控制BIU从外部获取）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的寄存器</p>
<ul>
<li>
<p>寄存器</p>
<ul>
<li>
<p>处理器内部的高速存储单元，用于暂存程序执行过程中的代码和数据</p>
</li>
<li>
<p>分类</p>
<ul>
<li>
<p>透明寄存器</p>
<ul>
<li>不可见，不能直接控制的寄存器</li>
<li>如保存指令代码的指令寄存器</li>
<li>透明指实际存在但是从某个角度看好像没有，即向上抽象</li>
</ul>
</li>
<li>
<p>可编程寄存器</p>
<ul>
<li>
<p>可以被程序员使用的寄存器，具有引用名称</p>
</li>
<li>
<p>分类</p>
<ul>
<li>
<p>通用寄存器</p>
<ul>
<li>数量较多，使用频率高，用来存放操作数据，地址</li>
</ul>
</li>
<li>
<p>专用寄存器</p>
<ul>
<li>用于特定目的，如指针寄存器IP记录执行指令的在地址，标志寄存器保存指令执行的辅助信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的寄存器组</p>
<ul>
<li></li>
<li>
<p>结构</p>
<ul>
<li>
<p>8个通用寄存器</p>
<ul>
<li>
<p>通用寄存器是多用途的，但在8086有它们各自的租用</p>
</li>
<li>
<p>数据寄存器</p>
<ul>
<li>
<p>可以分成高字节H和低字节L，如AX可以分为AH和AL</p>
</li>
<li>
<p>AX(Accumulator)</p>
<ul>
<li>
<p>累加器</p>
<ul>
<li>频率最高，用来算数和逻辑运算</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BX(Base)</p>
<ul>
<li>
<p>基址寄存器</p>
<ul>
<li>存放地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CX(Counter)</p>
<ul>
<li>
<p>计数器</p>
<ul>
<li>作为循环操作的计数器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DX(Data)</p>
<ul>
<li>
<p>数据寄存器</p>
<ul>
<li>存放数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变址寄存器</p>
<ul>
<li>
<p>有些指令有两个操作数，原操作数指参与运算的操作数，目的操作数是运算结果的操作数</p>
</li>
<li>
<p>SI(Source Index)</p>
<ul>
<li>
<p>原变址寄存器</p>
<ul>
<li>指向字符串或数组的原操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DI(Destination Index)</p>
<ul>
<li>
<p>目的变址寄存器</p>
<ul>
<li>指向字符串或数组的目的操作数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指针寄存器</p>
<ul>
<li>
<p>BP(Base Pointer)</p>
<ul>
<li>
<p>基址指针寄存器</p>
<ul>
<li>指向堆栈区域</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SP(Stack Pointer)</p>
<ul>
<li>
<p>堆栈指针寄存器</p>
<ul>
<li>指向堆栈顶部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4个段寄存器</p>
<ul>
<li>
<p>代码段寄存器CS</p>
<ul>
<li>存放指令代码</li>
</ul>
</li>
<li>
<p>堆栈段寄存器SS</p>
<ul>
<li>指明程序使用的堆栈区域</li>
</ul>
</li>
<li>
<p>数据段寄存器DS</p>
<ul>
<li>存放当前程序所用数据</li>
</ul>
</li>
<li>
<p>附加段寄存器ES</p>
</li>
</ul>
</li>
<li>
<p>1个标志寄存器</p>
<ul>
<li>
<p>标志(flag)</p>
<ul>
<li>用于反映执行结果或控制指令执行形式</li>
</ul>
</li>
<li>
<p>标志寄存器(FLAGS)/程序状态字寄存器(PSW)</p>
<ul>
<li>各种常用标志组成的16位寄存器，其中有6位状态标志和3位控制标志</li>
<li></li>
</ul>
</li>
<li>
<p>状态标志</p>
<ul>
<li>
<p>最基本的标志，用来记录指令执行结果的辅助信息</p>
</li>
<li>
<p>CF(Carry Flag)</p>
<ul>
<li>进位标志</li>
</ul>
</li>
<li>
<p>PF(Parity Flag)</p>
<ul>
<li>奇偶标志</li>
</ul>
</li>
<li>
<p>AF(Adjust Flag)</p>
<ul>
<li>调整标志</li>
</ul>
</li>
<li>
<p>ZF(Zero Flag)</p>
<ul>
<li>零标志</li>
</ul>
</li>
<li>
<p>SF(Sign Flag)</p>
<ul>
<li>符号标志</li>
</ul>
</li>
<li>
<p>OF(Overflow Flag)</p>
<ul>
<li>溢出标志</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制标志</p>
<ul>
<li>
<p>控制执行指令的方式</p>
</li>
<li>
<p>DF(Direction Flag)</p>
<ul>
<li>
<p>方向标志</p>
<ul>
<li>用于串操作指令</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IF(Interruptenable Flag)</p>
<ul>
<li>
<p>中断允许标志</p>
<ul>
<li>控制中断是否可以被处理器处理</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TF(Trap Flag)</p>
<ul>
<li>
<p>陷阱标志/单步标志</p>
<ul>
<li>控制处理器是否进入单步操作方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>1个指令指针寄存器</p>
<ul>
<li>
<p>IP(Instruction Pointer)</p>
<ul>
<li>
<p>指针寄存器</p>
<ul>
<li>存储执行指令的位置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指针寄存器有自动增量的能力，每完成一个指令，IP就会自增，分支循环操作也会自动跳转</p>
</li>
</ul>
</li>
<li>
<p>这些寄存器均为16位</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的存储器组织</p>
<ul>
<li>
<p>数据的存储格式</p>
<ul>
<li>
<p>基本单位</p>
<ul>
<li>
<p>二进制位(bit)</p>
<ul>
<li>存储一个二进制位0或1</li>
</ul>
</li>
<li>
<p>字节(Byte)</p>
<ul>
<li>8个二进制位</li>
</ul>
</li>
<li>
<p>字(word)</p>
<ul>
<li>2个字节16位</li>
</ul>
</li>
<li>
<p>双字(Double Word)</p>
<ul>
<li>4字节32位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>特殊位</p>
<ul>
<li>
<p>最低有效位</p>
<ul>
<li>D0</li>
</ul>
</li>
<li>
<p>最高有效位</p>
<ul>
<li>D7 D15 D31</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存储单位</p>
<ul>
<li>字节</li>
</ul>
</li>
<li>
<p>存储单元内容</p>
<ul>
<li>通过[存储地址]来表示某个存储单元的内容</li>
<li>如[0002H] = 1234H</li>
</ul>
</li>
<li>
<p>地址对齐</p>
<ul>
<li>若存储器是n位的，多字节数据起始要从能够模n的数的地址开始</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存储器的分段管理</p>
<ul>
<li>
<p>1MB存储空间分为许多逻辑段，每个段都是16位，每个存储单元用 段基地址 : 段内偏移地址 表达准确物理位置</p>
</li>
<li>
<p>段基地址</p>
<ul>
<li>说明段基段在主存中起始位置，用 xxxx0H的形式表示，通常保存在段寄存器中</li>
</ul>
</li>
<li>
<p>段偏移地址</p>
<ul>
<li>说明主存单元距离起始位置的偏移量</li>
</ul>
</li>
<li>
<p>物理地址/绝对地址</p>
<ul>
<li>即唯一的20位地址</li>
</ul>
</li>
<li>
<p>逻辑地址</p>
<ul>
<li>即段地址:偏移地址的表达方式</li>
</ul>
</li>
<li>
<p>逻辑地址和物理地址的关系</p>
<ul>
<li>段地址左移4位加上偏移地址可以得到物理地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段寄存器的作用</p>
<ul>
<li>
<p>保存对应逻辑段的段基地址</p>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>代码段寄存器CS</p>
<ul>
<li>存放程序的指令序列，CS存放段地址，IP存放偏移地址，通过 CS:IP 获取执行指令</li>
</ul>
</li>
<li>
<p>堆栈段寄存器SS</p>
<ul>
<li>存放堆栈段的段地址， 堆栈指针寄存器SP存放栈顶偏移地址， 通过 SS : SP 操作堆栈的数据</li>
</ul>
</li>
<li>
<p>数据段寄存器DS</p>
<ul>
<li>存放数据段地址， 便宜地址由主存寻址方式得到</li>
</ul>
</li>
<li>
<p>附加段寄存器ES</p>
<ul>
<li>附加的数据顿啊，可以用于数据的保存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一些特点</p>
<ul>
<li>程序指令必须安排在代码段</li>
<li>堆栈一定在堆栈段中</li>
<li>数据默认安排在数据段，有时安排在附加段，尤其是串操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8086寻址方式">8086寻址方式</h3>
<ul>
<li>
<p>立即数寻址方式</p>
<ul>
<li>即常数</li>
<li>mov ax, 10h</li>
</ul>
</li>
<li>
<p>寄存器寻址方式</p>
<ul>
<li>用寄存器名</li>
<li>mov ax, bx</li>
</ul>
</li>
<li>
<p>存储器寻址方式</p>
<ul>
<li>
<p>用存储器地址</p>
</li>
<li>
<p>mov ax, [2000H]</p>
<ul>
<li>默认段为DS，即 DS:[2000H]</li>
</ul>
</li>
</ul>
</li>
<li>
<p>寄存器间接寻址方式</p>
<ul>
<li>
<p>通过使用寄存器内的内容访问存储器</p>
</li>
<li>
<p>mov ax, [di + 06h]</p>
<ul>
<li>若是di，默认段为DS</li>
<li>若是bp，默认段为SS</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有效地址EA</p>
<ul>
<li>即括号内所有之和</li>
</ul>
</li>
</ul>
<h2 id="8086的指令系统">8086的指令系统</h2>
<h3 id="数据传送类指令">数据传送类指令</h3>
<ul>
<li>
<p>通用数据创送指令</p>
<ul>
<li>
<p>传送指令mov</p>
<ul>
<li>
<p>将操作数从原地址 src 传送至 目的地址 dest</p>
</li>
<li>
<p>mov 目的 源</p>
<ul>
<li>
<p>限制</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>
<p>若16进制首位是字母，则要加0</p>
</li>
<li>
<p>指明操作类型</p>
<ul>
<li>
<p>字节操作</p>
<ul>
<li>byte ptr</li>
</ul>
</li>
<li>
<p>字操作</p>
<ul>
<li>word ptr</li>
</ul>
</li>
</ul>
</li>
<li>
<p>源和目的的类型必须一致，否则为非法指令</p>
</li>
<li>
<p>立即数不允许被移动到段寄存器里面</p>
</li>
<li>
<p>不允许存储单元移动到存储单元，中间要借助寄存器</p>
</li>
<li>
<p>不允许段寄存器之间直接数据传送</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>交换指令XCHG</p>
<ul>
<li>
<p>将源和目的的内容交换</p>
</li>
<li>
<p>xchg 目的 源</p>
<ul>
<li>
<p>限制</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>换码指令XLAT</p>
<ul>
<li>将BX指定的缓冲区，AL指定的位移赋值给AL</li>
</ul>
</li>
</ul>
</li>
<li>
<p>堆栈操作指令</p>
<ul>
<li>
<p>进栈指令PUSH</p>
<ul>
<li>将操作数压入栈，计算机自动操作SP指针减2</li>
<li>push 操作数</li>
</ul>
</li>
<li>
<p>出栈指令POP</p>
<ul>
<li>将栈顶的一个字弹到指定的操作数，堆栈指针SP自动加2</li>
<li>pop 操作数</li>
</ul>
</li>
<li>
<p>一些特点</p>
<ul>
<li>堆栈可以用来临时存放数据</li>
<li>堆栈是从最高地址往下堆</li>
</ul>
</li>
<li>
<p>堆栈的应用</p>
<ul>
<li>堆栈基址指针指向堆栈区域，以便于使用堆栈内部的数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志传送指令</p>
<ul>
<li>
<p>标志寄存器传送</p>
<ul>
<li>
<p>标志送AH指令LAHF</p>
<ul>
<li>将FLAGS的弟子皆传送给寄存器AH</li>
<li>lahf</li>
</ul>
</li>
<li>
<p>AH送标志指令 SAHF</p>
<ul>
<li>将AH寄存器内容传送给FLAGS低字节</li>
<li>sahf</li>
</ul>
</li>
<li>
<p>标志进栈指令PUSHF</p>
<ul>
<li>将标志寄存器的内容压入栈</li>
<li>pushf</li>
</ul>
</li>
<li>
<p>标志出栈指令POPF</p>
<ul>
<li>将栈顶内容创送至标志寄存器</li>
<li>popf</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志位操作</p>
<ul>
<li>
<p>设置进位</p>
<ul>
<li>
<p>0</p>
<ul>
<li>clc</li>
</ul>
</li>
<li>
<p>1</p>
<ul>
<li>stc</li>
</ul>
</li>
<li>
<p>～</p>
<ul>
<li>cmc</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置方向</p>
<ul>
<li>
<p>0</p>
<ul>
<li>cld</li>
</ul>
</li>
<li>
<p>1</p>
<ul>
<li>std</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置中断</p>
<ul>
<li>
<p>0</p>
<ul>
<li>cli</li>
</ul>
</li>
<li>
<p>1</p>
<ul>
<li>sti</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>地址传送指令</p>
<ul>
<li>
<p>有效地址传送指令LEA</p>
<ul>
<li>将操作数的有效地址传送给寄存器</li>
<li>lea 目的, 源</li>
</ul>
</li>
<li>
<p>指针传送指令LDS/LES</p>
<ul>
<li>
<p>LDS</p>
<ul>
<li>将主存的连续4个字节作为地址分别放到寄存器和DS</li>
</ul>
</li>
<li>
<p>LES</p>
<ul>
<li>将主存的连续4个字节作为地址分别放到寄存器和ES</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算术运算类指令">算术运算类指令</h3>
<ul>
<li>
<p>用来执行算术运算</p>
</li>
<li>
<p>状态标志</p>
<ul>
<li>
<p>进位标志CF</p>
<ul>
<li>当进行运算后，如果CF=1，则说明运算过程最高位出现了进位或借位，否则说明没有</li>
<li>是针对无符号数据，用来说明最高位进位超出范围</li>
</ul>
</li>
<li>
<p>溢出标志OF</p>
<ul>
<li>若运算后数据溢出，则OF=1</li>
<li>针对有符号数据，用来说明有符号运算溢出</li>
</ul>
</li>
<li>
<p>其他状态标志</p>
<ul>
<li>
<p>零标志ZF</p>
<ul>
<li>反映运算结果是否为0（若ZF = 1 则 运算结果为0）</li>
</ul>
</li>
<li>
<p>符号标志SF</p>
<ul>
<li>用来判断符号位，最高位为1则SF为1</li>
</ul>
</li>
<li>
<p>奇偶标志PF</p>
<ul>
<li>判断8位数中1的个数为奇数或偶数，若为奇数，则PF = 0，只反映最低8位的个数，不能进行16位或32位操作</li>
</ul>
</li>
<li>
<p>调整标志AF</p>
<ul>
<li>反映低半字节是否向高字节进位或借位，若有则AF = 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>加法指令</p>
<ul>
<li>
<p>加法指令ADD</p>
<ul>
<li>
<p>add 目的,源</p>
<ul>
<li>
<p>将源操作数加上目的操作数并且把结果放在目的操作数</p>
</li>
<li>
<p>限制</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>在进行运算后FLAGS值会发生相应变化</p>
</li>
</ul>
</li>
<li>
<p>带进位加法指令ADC</p>
<ul>
<li>
<p>adc 目的,源</p>
<ul>
<li>和add应用方法一样，但是最后要加上一个进位cf，一般用于多精度的计算，当上一个add有进位时，下8位用ads可以保证进位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>增量指令INC</p>
<ul>
<li>
<p>inc 目的</p>
<ul>
<li>对操作数加1（不影响CF标志）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>减法指令</p>
<ul>
<li>
<p>减法指令SUB</p>
<ul>
<li>
<p>sub 目的, 源</p>
<ul>
<li>用目的操作数减去源操作数并将结果赋值给目的操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>带借位减法指令SBB</p>
<ul>
<li>
<p>sbb 目的, 源</p>
<ul>
<li>使目的操作数减去源操作数的同时再减去借位CF，用于结合SUB指令实现多精度加减法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>减量指令DEC</p>
<ul>
<li>
<p>dec 目的</p>
<ul>
<li>对操作数减1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>求补指令NEG</p>
<ul>
<li>
<p>neg 目的</p>
<ul>
<li>对目的操作数求补</li>
</ul>
</li>
</ul>
</li>
<li>
<p>比较指令CMP</p>
<ul>
<li>
<p>cmp 目的, 源</p>
<ul>
<li>将目的操作数减去源操作数，影响标志，但是最后不把结果返回给目的操作数</li>
<li>可以用于比较大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>乘法指令</p>
<ul>
<li>
<p>无符号乘法指令MUL</p>
<ul>
<li>
<p>mul 源</p>
<ul>
<li>若源操作数是8位，则将al与源操作数相乘，并将结果放入ax中</li>
<li>若源操作数是16位，则将ax与原操作数相乘，并将结果的低字节放入ax中，高字节放入dx中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有符号数乘法指令IMUL</p>
<ul>
<li>
<p>imul 源</p>
<ul>
<li>和mul相同，但是是有符号相乘</li>
</ul>
</li>
</ul>
</li>
<li>
<p>乘法指令只有OF和CF的标志位有效，其他标志位不可预测</p>
</li>
</ul>
</li>
<li>
<p>除法指令</p>
<ul>
<li>
<p>无符号二进制数除法指令DIV</p>
<ul>
<li>
<p>div 源</p>
<ul>
<li>若源操作数是8位，则将ax与源操作相除，并将商放入al中,余数放入ah中</li>
<li>若源操作数是16位，则将ax,dx与原操作数相除，并将结果的商放入ax中，余数放入dx中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有符号二进制数除法指令IDIV</p>
<ul>
<li>
<p>idiv 源</p>
<ul>
<li>与div相同，但是有符号相除</li>
</ul>
</li>
</ul>
</li>
<li>
<p>被除数远大于除数时，会溢出，然后程序停止</p>
</li>
</ul>
</li>
<li>
<p>符号扩展指令</p>
<ul>
<li>
<p>当需要将一些低位数据与高位数据进行运算时，要先将低位数据扩张为高位数据，但是本身数据大小不能改变</p>
</li>
<li>
<p>无符号数据扩展</p>
<ul>
<li>直接在前面加0</li>
</ul>
</li>
<li>
<p>有符号数据扩展</p>
<ul>
<li>需要进行符号扩展，在前面加上符号位的值</li>
</ul>
</li>
<li>
<p>符号扩展指令</p>
<ul>
<li>
<p>8位扩展16位指令CBW</p>
<ul>
<li>将AL扩展到AX</li>
</ul>
</li>
<li>
<p>16位扩张32位指令CWD</p>
<ul>
<li>将AX扩展到DX</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>十进制调整指令</p>
<ul>
<li>
<p>压缩BCD码调整指令</p>
<ul>
<li>
<p>压缩BCD码</p>
<ul>
<li>通常的8421码，用4个二进制位表示一个十进制位，一字节可以表示两个二进制位</li>
</ul>
</li>
<li>
<p>压缩BCD码调整指令</p>
<ul>
<li>
<p>对二进制加减法指令的执行结果进行调整得到十进制结果，在执行他们之前要先执行加法或减法指令</p>
</li>
<li>
<p>加法十进制调整指令DAA</p>
<ul>
<li>
<p>daa</p>
<ul>
<li>在以al为目的操作数的add运算后，对al的二进制结果进行十进制调整，在al中得到十进制结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>减法十进制调整指令DAS</p>
<ul>
<li>
<p>das</p>
<ul>
<li>和daa一样，不过是跟在sub之后</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对OF标志位无定义，影响其他所有标志，CF反映BCD码的进位状态</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非压缩BCD码调整指令</p>
<ul>
<li>
<p>非压缩BCD码</p>
<ul>
<li>用8个二进制为表示一个十进制位，即用ASCII编码表示十进制位</li>
</ul>
</li>
<li>
<p>非压缩BCD码调整指令</p>
<ul>
<li>
<p>加法非压缩BCD调整指令AAA</p>
<ul>
<li>aaa</li>
</ul>
</li>
<li>
<p>减法非压缩BCD码调整指令AAS</p>
<ul>
<li>aas</li>
</ul>
</li>
<li>
<p>乘法非压缩BCD码调整指令AAD</p>
<ul>
<li>aad</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="位操作类指令">位操作类指令</h3>
<ul>
<li>
<p>逻辑运算指令</p>
<ul>
<li>
<p>逻辑与指令 AND</p>
<ul>
<li>
<p>and 目的, 源</p>
<ul>
<li>对两个操作数执行按位与运算，将结果创送给目的操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑或指令 OR</p>
<ul>
<li>or 目的, 源</li>
</ul>
</li>
<li>
<p>逻辑异或指令 XOR</p>
<ul>
<li>xor 目的, 源</li>
</ul>
</li>
<li>
<p>逻辑非指令 NOT</p>
<ul>
<li>not 目的, 源</li>
</ul>
</li>
<li>
<p>测试指令 TEST</p>
<ul>
<li>
<p>test 目的, 源</p>
<ul>
<li>对两者进行与运算，但不把结果赋值给目的，保留标志位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志位</p>
<ul>
<li>CF = OF = 0,其他标志位看结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>移位指令</p>
<ul>
<li>
<p>逻辑左移 SHL</p>
<ul>
<li>
<p>shl 目的, 1/cl</p>
<ul>
<li>将数据左移,若源是1，移动1位，若要移动多于1位，则用cl寄存器代替，最低位补0，最高位进入cf</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑右移 SHR</p>
<ul>
<li>
<p>shr 目的, 1/cl</p>
<ul>
<li>最高位补0，最低位进入cf</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算数左移 SAL</p>
<ul>
<li>
<p>sal 目的, 1/cl</p>
<ul>
<li>与逻辑左移相同</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算数右移 SAR</p>
<ul>
<li>
<p>sar 目的, 1/cl</p>
<ul>
<li>补充的时候补充最高位的值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志位</p>
<ul>
<li>CF和OF有定义，当移动次数大于1时，OF无定义，其他位全部无定义</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环移位指令</p>
<ul>
<li>类似移位指令，但从一段移出的位返回到另一端</li>
<li>不带进位循环左移 ROL</li>
<li>不带进位循环右移 ROR</li>
<li>带进位循环左移 RCL</li>
<li>带进位循环右移 RCR</li>
</ul>
</li>
</ul>
<h3 id="控制转移类指令">控制转移类指令</h3>
<ul>
<li>
<p>无条件转移指令 JMP</p>
<ul>
<li>
<p>段内转移，相对寻址</p>
<ul>
<li>
<p>jmp 8位或16位位移量</p>
<ul>
<li>IP = IP + 位移量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段内转移，间接寻址</p>
<ul>
<li>
<p>jmp 源</p>
<ul>
<li>IP = 源操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段间转移，直接寻址</p>
<ul>
<li>
<p>jmp far ptr 32位逻辑地址</p>
<ul>
<li>cs会变成到逻辑地址的段地址，ip会变成逻辑地址的偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段间转移，间接寻址</p>
<ul>
<li>
<p>jmp far ptr 主存地址</p>
<ul>
<li>将主存地址当做ip，该主存地址的高位当做段地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>条件转移指令 jcc</p>
<ul>
<li>
<p>jcc 8位位移量</p>
<ul>
<li>若条件满足，则ip加上位移量，否则加上2，进入下一条语句</li>
<li>cc代表利用标志判断条件</li>
</ul>
</li>
<li>
<p>判断满足条件</p>
<ul>
<li>
<p>常用满足条件</p>
<ul>
<li>
<p>等于0/不等于0</p>
<ul>
<li>
<p>jz/jnz</p>
<ul>
<li>标志位ZF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>符号为负/正</p>
<ul>
<li>
<p>js/jns</p>
<ul>
<li>标志位SF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>溢出</p>
<ul>
<li>
<p>jo</p>
<ul>
<li>标志位OF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进位/无进位</p>
<ul>
<li>
<p>jc/jnc</p>
<ul>
<li>标志位CF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大于等于</p>
<ul>
<li>JNL</li>
</ul>
</li>
<li>
<p>小于等于</p>
<ul>
<li>JLE</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环指令</p>
<ul>
<li>
<p>jcxz 8位位移量</p>
<ul>
<li>cx为0则ip加上位移量，否则顺序执行</li>
</ul>
</li>
<li>
<p>loop 8位位移量</p>
<ul>
<li>先将cx减去1，若cx不为0，ip加上位移量，否则顺序执行</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序指令</p>
<ul>
<li>
<p>子程序调用指令CALL</p>
<ul>
<li>
<p>段内调用</p>
<ul>
<li>
<p>相对寻址</p>
<ul>
<li>
<p>call 十六位位移量</p>
<ul>
<li>先把当前ip地址压入栈，再将ip加上位移量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>间接寻址</p>
<ul>
<li>call 源</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段间调用</p>
<ul>
<li>
<p>直接寻址</p>
<ul>
<li>
<p>call far ptr 十六位位移量</p>
<ul>
<li>先把ip移入栈，再将cs换到位移量的段地址，ip换到位移量的偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>间接寻址</p>
<ul>
<li>call far ptr 主存地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序返回指令RET</p>
<ul>
<li>
<p>无参数返回</p>
<ul>
<li>
<p>ret</p>
<ul>
<li>将栈弹出给ip</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有参数返回</p>
<ul>
<li>
<p>ret 十六位数据</p>
<ul>
<li>将栈弹出给ip, 并且将数据压入栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中断指令</p>
<ul>
<li>
<p>中断概念</p>
<ul>
<li>程序运行时遇到紧急情况时，当前程序会暂停，转去执行这些紧急情况的程序段</li>
</ul>
</li>
<li>
<p>8086的中断类型</p>
<ul>
<li>
<p>外部中断</p>
<ul>
<li>
<p>指来自cpu之外的原因引起的程序中断</p>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>可屏蔽中断</p>
<ul>
<li>
<p>指中断请求可以被cpu内部屏蔽</p>
</li>
<li>
<p>由标志寄存器中的IF控制</p>
<ul>
<li>在任何一个中断服务程序被执行后，或者执行关中断指令CLI后，IF=0，cpu屏蔽中断，称为关中断状态</li>
<li>当中断服务程序结束，执行中断返回指令IRET时，回复中断前IF状态</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非屏蔽中断</p>
<ul>
<li>不受IF标志影响，CPU必须执行的指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内部中断</p>
<ul>
<li>
<p>指CPU内部执行程序引起的程序中断，也称异常</p>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>除法错中断</p>
<ul>
<li>除数为0或者商超过寄存器能表达的范围，向量表中排号为0</li>
</ul>
</li>
<li>
<p>指令中断</p>
<ul>
<li>也叫软件中断，通过INT n产生指令中断，n是指令码，当n等于3，执行中断调用指令,常用作程序调试的断点中断，向量表中排号为3</li>
</ul>
</li>
<li>
<p>溢出中断</p>
<ul>
<li>执行溢出中断指令INTO，当OF为1，产生溢出中断，向量表中排号为4</li>
</ul>
</li>
<li>
<p>单步中断</p>
<ul>
<li>当单步标志TF为1时，每条指令执行完后都产生单步中断向量表中排号为1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的中断过程</p>
<ul>
<li>
<p>中断服务程序</p>
<ul>
<li>中断服务程序可以被看成一个子程序，放在主存的任何位置，它的程序首地址被放在中断向量表中</li>
</ul>
</li>
<li>
<p>中断向量表</p>
<ul>
<li>设置在主存的最低1kb区域，物理地址为000H~3FFH，从0开始每4字节对应一个中断，低字节存放中断服务程序的偏移地址IP，高字节存放段地址CS</li>
</ul>
</li>
<li>
<p>中断处理过程</p>
<ul>
<li>先将标志寄存器压入栈</li>
<li>禁止中断过程有中断 ：IF = 0, TF = 0</li>
<li>将断点地址压入栈，先压入段地址，再压入偏移地址</li>
<li>读取中断服务程序的起始地址，进入中断服务程序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的中断指令</p>
<ul>
<li>
<p>中断指令INT</p>
<ul>
<li>
<p>int 8位数据</p>
<ul>
<li>产生n号中断</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中断返回指令IRET</p>
<ul>
<li>
<p>iret</p>
<ul>
<li>类似函数的ret，实现中断返回</li>
</ul>
</li>
</ul>
</li>
<li>
<p>溢出中断指令INTO</p>
<ul>
<li>
<p>into</p>
<ul>
<li>当溢出标志of为1时调用该指令，产生4号中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="处理机控制类指令">处理机控制类指令</h3>
<ul>
<li>
<p>作用</p>
<ul>
<li>用来控制各种CPU的操作，例如暂停，等待或空操作</li>
</ul>
</li>
<li>
<p>空操作指令NOP</p>
<ul>
<li>
<p>nop</p>
<ul>
<li>不执行任何有意义的操作，占用1字节存储单元，空号一个指令执行周期，常用于软件延时，它的执行和 XCHG AX,AX本质一样</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段超越SEG</p>
<ul>
<li>
<p>seg:</p>
<ul>
<li>seg就是段名，cs, ss, ds, es, 在允许段超越的存储器操作数之前，使用该指令可以采用指定的段寄存器寻址操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>封锁前缀指令LOCK</p>
<ul>
<li>
<p>lock</p>
<ul>
<li>执行后，在这个指令执行时间内，封锁输出引脚，即封锁总线，让别的控制器无法控制总线，可以用来避免破坏有用信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>暂停指令HLT</p>
<ul>
<li>
<p>hlt</p>
<ul>
<li>让CPU进入暂停状态，当CPU发生复位或外部中断时，脱离暂停状态，当程序需要等待中断时，使用该指令可以让软件不进入死循环，然后CPU通过中断脱离暂停，并执行hlt的吓一跳指令，该指令相当于死机，一般应用程序不要使用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>交权指令ESC</p>
<ul>
<li>
<p>esc 6位立即数, 寄存器或主存</p>
<ul>
<li>交权给外部协处理器，如浮点运算交给外部处理器8087</li>
</ul>
</li>
</ul>
</li>
<li>
<p>等待指令WAIT</p>
<ul>
<li>当8086测试输入引脚为高电平无效时，CPU进入等待状态，此时CPU不进行任何操作，测试为低电平有效时，继续执行指令，如交权给外部处理器时为了保持同步，8086应利用wait指令保持同步</li>
</ul>
</li>
</ul>
<h2 id="汇编语言程序格式">汇编语言程序格式</h2>
<h3 id="汇编语言程序的开发">汇编语言程序的开发</h3>
<ul>
<li>
<p>汇编语言程序的语句格式</p>
<ul>
<li>
<p>语句类型</p>
<ul>
<li>
<p>执行性语句</p>
<ul>
<li>标号: 处理器指令助记符 操作数, 操作数</li>
</ul>
</li>
<li>
<p>说明性语句</p>
<ul>
<li>名字 伪指令助记符 参数, 参数, ...</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标号与名字</p>
<ul>
<li>
<p>标号</p>
<ul>
<li>在执行性语句中，&quot;:&quot;前面的标号表示处理器指令在主存中的逻辑地址，主要用于指示分支</li>
</ul>
</li>
<li>
<p>名字</p>
<ul>
<li>说明性语句中的名字反应变量，段和子程序的逻辑地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>助记符</p>
<ul>
<li>
<p>帮助记忆指令的符号，反映指令的功能</p>
</li>
<li>
<p>助记符db</p>
<ul>
<li>分配一段存储空间，保存变量值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>操作数和参数</p>
<ul>
<li>即源操作数，目的操作数等</li>
</ul>
</li>
<li>
<p>注释</p>
<ul>
<li>语句中 &quot; ; &quot; 之后的内容是注释</li>
</ul>
</li>
</ul>
</li>
<li>
<p>汇编语言的源程序框架</p>
<ul>
<li>
<p>.model small</p>
<ul>
<li>
<p>定义程序的存储模式</p>
<ul>
<li>small表示小型模式</li>
</ul>
</li>
</ul>
</li>
<li>
<p>.stack</p>
<ul>
<li>定义堆栈段</li>
</ul>
</li>
<li>
<p>,data</p>
<ul>
<li>定义数据段</li>
</ul>
</li>
<li>
<p>数据定义</p>
</li>
<li>
<p>.code</p>
<ul>
<li>定义代码段</li>
</ul>
</li>
<li>
<p>.startup</p>
<ul>
<li>程序起始点</li>
</ul>
</li>
<li>
<p>主程序代码</p>
</li>
<li>
<p>.exit 0</p>
<ul>
<li>程序终止点</li>
</ul>
</li>
<li>
<p>子程序代码</p>
</li>
<li>
<p>end</p>
<ul>
<li>汇编结束</li>
</ul>
</li>
</ul>
</li>
<li>
<p>汇编语言程序的开发过程</p>
<ul>
<li>
<p>先安装开发软件，MASM 6.x完全版</p>
<ul>
<li>
<p>MASM软件包文件</p>
<ul>
<li>
<p>主程序目录</p>
<ul>
<li>
<p>配置MASM的基本文件</p>
<ul>
<li>
<p>汇编程序</p>
<ul>
<li>ml.exe</li>
</ul>
</li>
<li>
<p>汇编错误信息文件</p>
<ul>
<li>ml.err</li>
</ul>
</li>
<li>
<p>连接程序</p>
<ul>
<li>link.exe</li>
</ul>
</li>
<li>
<p>子程序库管理文件</p>
<ul>
<li>lib.exe</li>
</ul>
</li>
</ul>
</li>
<li>
<p>含有作者创建的文件</p>
</li>
</ul>
</li>
<li>
<p>HELP目录</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DOS系统功能调用</p>
<ul>
<li>
<p>方法</p>
<ul>
<li>先在AH寄存器中设置系统功能调用号，说明选择功能</li>
<li>在指定的寄存器设置入口参数，以便系统执行功能</li>
<li>调用中断指令 INT 21H 执行功能调用</li>
</ul>
</li>
<li>
<p>基本功能调用</p>
<ul>
<li>
<p>输入字符</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 01H</li>
</ul>
</li>
<li>
<p>出口参数</p>
<ul>
<li>AL = 输入字符的ASCII码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输出字符</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 02H</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>DL = 输入字符的ASCII码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输出字符串</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 09H</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>DS:DX = 字符串的地址</li>
<li>通过 offset 字符串名字 来获取字符串的地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输入字符串</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 0AH</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>DS:DX = 缓冲区的地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>判断键盘是否输入</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 0BH</li>
</ul>
</li>
<li>
<p>出口参数</p>
<ul>
<li>AL = 0 :无, AL = FFH :有</li>
</ul>
</li>
</ul>
</li>
<li>
<p>终止程序</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 4CH</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>AL = 返回代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="参数变量和标号">参数，变量和标号</h3>
<ul>
<li>
<p>数值型参数</p>
<ul>
<li>
<p>常数</p>
<ul>
<li>
<p>十进制</p>
<ul>
<li>以D结尾</li>
</ul>
</li>
<li>
<p>十六进制</p>
<ul>
<li>以H结尾</li>
</ul>
</li>
<li>
<p>二进制</p>
<ul>
<li>以B结尾</li>
</ul>
</li>
<li>
<p>八进制</p>
<ul>
<li>以Q结尾</li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串常数</p>
<ul>
<li>用单引号括起来的一个或多个字符，如 'string'</li>
</ul>
</li>
<li>
<p>符号常数</p>
<ul>
<li>
<p>利用一个标识符去表达一个常数</p>
<ul>
<li>符号名 equ 常数</li>
<li>符号名 equ &lt;字符串&gt;</li>
<li>符号名 = 常数</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>符号名 = 常数 可行，但是 符号名 = 符号名 + 常数不可行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量定义伪指令</p>
<ul>
<li>
<p>定义</p>
<ul>
<li>为变量分配固定长度的存储空间</li>
</ul>
</li>
<li>
<p>汇编格式</p>
<ul>
<li>变量名 伪指令 初值表</li>
</ul>
</li>
<li>
<p>解释</p>
<ul>
<li>
<p>变量名</p>
<ul>
<li>变量名代表了分配的逻辑地址，可以没有变量名，这种情况计算机仅仅分配地址</li>
</ul>
</li>
<li>
<p>初值表</p>
<ul>
<li>
<p>给分配的空间赋初值</p>
<ul>
<li>
<p>分配某确定初值</p>
<ul>
<li>初值表为 数值</li>
</ul>
</li>
<li>
<p>不确定初值</p>
<ul>
<li>初值表为 ？</li>
</ul>
</li>
<li>
<p>重复初值</p>
<ul>
<li>初值表为 重复次数 dup(重复参数)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>伪指令</p>
<ul>
<li>根据申请的主存空间单位分类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>伪指令类型</p>
<ul>
<li>
<p>定义字节单元伪指令DB</p>
<ul>
<li>分配1字节或多字节单元</li>
</ul>
</li>
<li>
<p>定义字单元伪指令DW</p>
<ul>
<li>分配1字(2字节)或多字单元</li>
</ul>
</li>
<li>
<p>定义双字单元伪指令DD</p>
<ul>
<li>分配一个或多个双字单环(4字节)</li>
</ul>
</li>
<li>
<p>定义3字伪指令DF</p>
</li>
<li>
<p>定义4字伪指令DQ</p>
</li>
<li>
<p>定义10字节伪指令DT</p>
</li>
<li>
<p>定位伪指令</p>
<ul>
<li>
<p>控制数据分配位置参数ORG</p>
<ul>
<li>
<p>org 100h</p>
<ul>
<li>在100h处分配空间</li>
</ul>
</li>
<li>
<p>org $+10</p>
<ul>
<li>将偏移地址+10后分配空间</li>
<li>$表示当前偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>偶数化当前偏移地址参数EVEN</p>
<ul>
<li>
<p>even</p>
<ul>
<li>将当前偏移地址偶数化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对其偏移地址参数ALIGN</p>
<ul>
<li>
<p>align n</p>
<ul>
<li>以n的倍数对齐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量与标号的属性</p>
<ul>
<li>
<p>标号和名字的属性</p>
<ul>
<li>
<p>地址属性</p>
<ul>
<li>标号和名字对应的存储单元的逻辑地址，包括段地址和偏移地址</li>
</ul>
</li>
<li>
<p>类型属性</p>
<ul>
<li>
<p>标号，子程序的类型</p>
<ul>
<li>near(近)/far(远)</li>
</ul>
</li>
<li>
<p>变量名类型</p>
<ul>
<li>byte,word,dword</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>地址操作符</p>
<ul>
<li>
<p>返回名字的标号或偏移地址</p>
<ul>
<li>offset 名字/标号</li>
</ul>
</li>
<li>
<p>返回名字或标号的段地址</p>
<ul>
<li>seg 名字/标号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类型操作符</p>
<ul>
<li>
<p>临时改变名字和标号的类型</p>
<ul>
<li>类型名 ptr 名字/标号</li>
</ul>
</li>
<li>
<p>分配当前地址给变量名，并且不将逻辑地址向后移动，相当于用两个变量名给同一个地址空间命名</p>
<ul>
<li>this 类型名</li>
<li>name equ this byte</li>
</ul>
</li>
<li>
<p>返回名字或标号的类型对应的数值</p>
<ul>
<li>
<p>TYPE 名字/标号</p>
</li>
<li>
<p>对应数值</p>
<ul>
<li>
<p>变量</p>
<ul>
<li>每个数据占用字节数</li>
</ul>
</li>
<li>
<p>标号</p>
<ul>
<li>逻辑地址</li>
</ul>
</li>
<li>
<p>结构</p>
<ul>
<li>每个结构元素占用的字节数</li>
</ul>
</li>
<li>
<p>寄存器</p>
<ul>
<li>该寄存器具有的字节数</li>
</ul>
</li>
<li>
<p>常数</p>
<ul>
<li>0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序段的定义和属性">程序段的定义和属性</h3>
<ul>
<li>
<p>DOS的程序结构</p>
<ul>
<li>
<p>EXE 程序</p>
<ul>
<li>
<p>exe程序的简介</p>
<ul>
<li>利用程序开发工具，所生成的可执行程序，拥有堆栈段，一个或多个的代码数据段，执行起始处可以任意指定</li>
</ul>
</li>
<li>
<p>exe文件在磁盘上的组成</p>
<ul>
<li>
<p>文件头</p>
<ul>
<li>
<p>生成</p>
<ul>
<li>由连接程序生成</li>
</ul>
</li>
<li>
<p>内容</p>
<ul>
<li>文件的控制信息</li>
<li>重定位信息</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>供DOS装入EXE文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>装入模块</p>
<ul>
<li>即程序本身</li>
</ul>
</li>
<li>
<p>附加部分(有些大型exe文件有)</p>
<ul>
<li>仅供程序本身使用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DOS装入或执行程序过程</p>
<ul>
<li>
<p>选择起始点作为程序段</p>
<ul>
<li>在这个过程中，DOS确定当时主存最低可用地址作为程序装入的起始点作为程序段</li>
</ul>
</li>
<li>
<p>生成程序段前缀块PSP</p>
<ul>
<li>在起始点生成一个256字节的程序段前缀控制块PSP（100H）</li>
</ul>
</li>
<li>
<p>装入程序本身</p>
<ul>
<li>将代码段，数据段，堆栈段...装在PSP上面</li>
</ul>
</li>
</ul>
</li>
<li>
<p>exe程序的加载</p>
<ul>
<li>
<p>重新定位</p>
<ul>
<li>将DS，ES指向PSP段地址</li>
<li>通过连接程序确定CS：IP和SS：SP的值</li>
<li>装载成功，开始执行IP指向的第一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>COM 程序</p>
<ul>
<li>
<p>COM程序的简介</p>
<ul>
<li>将代码数据和堆栈段合一的结构紧凑的程序，将所有代码数据都放在一个逻辑段里面，不超过64kb，在程序开发是需要满足一定条件并采用相应参数才能生成COM程序</li>
</ul>
</li>
<li>
<p>COM程序的特点</p>
<ul>
<li>在磁盘上是主存的完全影像，不包含定位加载信息，相比exe加载速度快，占用空间少</li>
</ul>
</li>
<li>
<p>COM程序的加载过程</p>
<ul>
<li>所有的段地址都指向PSP</li>
<li>IP=100H，即PSP后面一定要是可执行指令</li>
<li>堆栈区设置在段尾，栈底设置0000</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>简化段定义的格式</p>
<ul>
<li>
<p>存储模型伪指令</p>
<ul>
<li>
<p>作用</p>
<ul>
<li>决定一个程序的规模，确定了子程序的调用，指令转移和数据访问的默认属性</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li>,model 存储模型[语言类型][从操作系统类型][堆栈选项]</li>
</ul>
</li>
<li>
<p>存储模型</p>
<ul>
<li>
<p>微型模型TINY</p>
<ul>
<li>
<p>所有段地址寄存器被设置为同一值，代码段数据段堆栈段在同一个段内，总大小不大于64kb</p>
</li>
<li>
<p>作用</p>
<ul>
<li>用于创建COM类型程序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>小型模型SMALL</p>
<ul>
<li>一个程序之多有一个代码段和一个数据段（包含数据段，堆栈段和附加段，它们公用一个段基址），每个段不大于64kb，所以最大长度为128kb</li>
<li>偏移地址用16位就可以访问所有空间，所以各种操作的数据范围都是近指针</li>
</ul>
</li>
<li>
<p>紧凑模型COMPACT</p>
<ul>
<li>代码段限制在64kb的段内，但是数据段可以有多个，超过64kb，这个模型数据指针默认为远指针，用于定位数据段，调用为近调用</li>
<li>用于数据量大但是代码量小的程序</li>
</ul>
</li>
<li>
<p>中型模型MEDIUM</p>
<ul>
<li>和紧凑模型互补，可以有多个代码段，都可以可以超过64kb，但是数据段只能有不大于64kb的段</li>
<li>适合数据量小但是代码量大的程序</li>
</ul>
</li>
<li>
<p>大型模型LARGE</p>
<ul>
<li>代码段和数据段都有多个，都可以超过64kb，但是静态数据依然限制在64kb内</li>
</ul>
</li>
<li>
<p>巨型模型HUGE</p>
<ul>
<li>相比于大型模型静态数据没有限制</li>
</ul>
</li>
<li>
<p>平展模型FLAT</p>
<ul>
<li>创建一个32位的程序，要使用32位x86处理器的伪指令</li>
<li>32位windows应用程序必须用FLAT模型，DOS不能使用该模型</li>
</ul>
</li>
<li>
<p>产生的文件</p>
<ul>
<li>TINY模型尝试COM文件，其他模型尝试EXE程序，FLAT模型只用于32位程序，高级语言混合编程时存储模型要一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>简化段定义伪指令</p>
<ul>
<li>
<p>定义</p>
<ul>
<li>
<p>语句.CODE .DATA .STACK分别表达数据段和堆栈段的开始</p>
<ul>
<li>在简化段定义指令之前必须有存储模型语句MODEL</li>
</ul>
</li>
</ul>
</li>
<li>
<p>堆栈段伪指令 .STACK</p>
<ul>
<li>.stack [大小]</li>
<li>创建一个堆栈段，参数指定堆栈段占的字节数，默认1KB</li>
</ul>
</li>
<li>
<p>数据段伪指令.DATA</p>
<ul>
<li>.data<br>
.data？</li>
<li>有初值变量定义在.data中，无初值变量定义在.data?中，这里面的数据是在程序运行后才分配空间</li>
</ul>
</li>
<li>
<p>代码段伪指令.CODE</p>
<ul>
<li>.code [段名]</li>
<li>创建一个代码段，参数指定改代码短的段名，如果没有给参数用默认段名，在TINY，SMALL，COMPACT，FLAT模型下默认段名是“_TEXT”，在大型的默认段名是“模块名_TEXT”</li>
</ul>
</li>
<li>
<p>程序开始伪指令.STARTUP</p>
<ul>
<li>.startup</li>
<li>按照cpu类型和选择的模型，操作系统和堆栈类型，产生开始执行的代码，同时指定程序开始的起始点。该语句初始化DS值，调整了SS和SP的值。</li>
</ul>
</li>
<li>
<p>程序终止伪指令.EXIT</p>
<ul>
<li>.exit [返回代码]</li>
<li>该语句产生终止程序的代码，参数为0表示没有错误</li>
</ul>
</li>
<li>
<p>汇编结束伪指令END</p>
<ul>
<li>end [标号]</li>
<li>表示汇编程序到此结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本汇编语言程序设计">基本汇编语言程序设计</h2>
<h3 id="循环程序设计">循环程序设计</h3>
<ul>
<li>
<p>串操作类指令</p>
<ul>
<li>
<p>操作数据串的指令</p>
</li>
<li>
<p>串传送指令</p>
<ul>
<li>
<p>串传送指令MOVS</p>
<ul>
<li>
<p>将数据段中的字节或子数据传送至ES指向的段</p>
</li>
<li>
<p>movsb</p>
<ul>
<li>字节串传送</li>
<li>将ds:[si]赋给es:[di],并且移动si和di一字节</li>
</ul>
</li>
<li>
<p>movsw</p>
<ul>
<li>字串传送</li>
<li>将ds:[si]赋给es:[di],并且移动si和di两字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>串存储指令STOS</p>
<ul>
<li>
<p>将AL或AX的内容存入ES指向的段</p>
</li>
<li>
<p>stosb</p>
<ul>
<li>将al给 es:[di],然后di移动一字节</li>
</ul>
</li>
<li>
<p>stosw</p>
<ul>
<li>将ax给 es:[di],然后di移动两字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>串读取指令LODS</p>
<ul>
<li>
<p>将数据段中的数据传给AL或AX</p>
</li>
<li>
<p>lodsb</p>
<ul>
<li>将ds:[si]给al，然后si移动一字节</li>
</ul>
</li>
<li>
<p>lodsw</p>
<ul>
<li>将ds:[si]给ax，然后si移动一字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重复前缀指令REP</p>
<ul>
<li>重复cx次指令</li>
</ul>
</li>
<li>
<p>书写串名方式</p>
<ul>
<li>movs 目的串名,源串名</li>
</ul>
</li>
<li>
<p>使用方法</p>
<ul>
<li>在使用MOVS之前，要提前设置好DS，ES，SI，DI和方向标志DF，并将CX设置成重复的次数</li>
<li>通常DF设置为0，为地址增加方式</li>
</ul>
</li>
</ul>
</li>
<li>
<p>串检测指令</p>
<ul>
<li>
<p>串比较指令CMPS</p>
<ul>
<li>
<p>cmpsb</p>
<ul>
<li>将DS:[SI] - ES:[DI],然后移动si和di一字节</li>
</ul>
</li>
<li>
<p>cmpsw</p>
</li>
</ul>
</li>
<li>
<p>串扫描指令</p>
<ul>
<li>
<p>scasb</p>
<ul>
<li>将al-ES:[DI],移动di一字节</li>
</ul>
</li>
<li>
<p>scasw</p>
</li>
</ul>
</li>
<li>
<p>重复且判断前缀指令REPE</p>
<ul>
<li>
<p>repe|repz</p>
<ul>
<li>CX等于零或ZF等于一停止比较</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重复且判断前缀指令REPNE</p>
<ul>
<li>
<p>repne|repnz</p>
<ul>
<li>CX等于零</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="子程序设计">子程序设计</h3>
<ul>
<li>
<p>过程定义伪指令</p>
<ul>
<li>
<p>子程序</p>
<ul>
<li>具有唯一子程序名的程序段</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li>子程序名 proc[near/far]<br>
过程体<br>
子程序名 endp</li>
</ul>
</li>
<li>
<p>属性</p>
<ul>
<li>
<p>near</p>
<ul>
<li>只能被相同代码段的其他程序调用</li>
</ul>
</li>
<li>
<p>far</p>
<ul>
<li>可以被不同代码段的程序调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>调用</p>
<ul>
<li>
<p>call 子程序名</p>
<ul>
<li>将返回地址压入栈</li>
</ul>
</li>
</ul>
</li>
<li>
<p>返回</p>
<ul>
<li>
<p>ret</p>
<ul>
<li>从当前栈顶取内容作为返回地址</li>
<li>注意执行ret之前要把子程序过程中压入的数据清空</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>
<p>过程设计要注意寄存器的保护和恢复</p>
</li>
<li>
<p>方式</p>
<ul>
<li>程序开始压栈，程序结束弹栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序的参数传递</p>
<ul>
<li>
<p>用寄存器传递参数</p>
<ul>
<li>
<p>传递少量参数</p>
<ul>
<li>将数据保存在寄存器，并且不进行寄存器恢复</li>
</ul>
</li>
<li>
<p>传递大量参数</p>
<ul>
<li>将参数保存在连续的存储地址中，寄存器将该连续地址的首地址进行保存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用变量传递参数</p>
<ul>
<li>等效于用全局变量传参，通用性较差</li>
</ul>
</li>
<li>
<p>用堆栈传递参数</p>
<ul>
<li>
<p>现将传入的参数压入栈</p>
</li>
<li>
<p>将bp压入栈</p>
<ul>
<li>保护寄存器</li>
</ul>
</li>
<li>
<p>将bp指向栈顶sp</p>
<ul>
<li>mov bp, sp</li>
</ul>
</li>
<li>
<p>将要用的寄存器压入栈</p>
</li>
<li>
<p>使用压入的参数</p>
<ul>
<li>[bp+4 + 2i]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序的嵌套递归和重入</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代码随想录day10]]></title>
        <id>https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day10/</id>
        <link href="https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day10/">
        </link>
        <updated>2023-10-20T09:27:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定义">定义</h3>
<p>队列是先进先出，栈是先进后出<br>
<img src="https://moyihust.github.io/post-images/1697970258566.png" alt="" loading="lazy"></p>
<p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。<br>
栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。<br>
栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的<br>
我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。<br>
deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。<br>
<strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong><br>
我们也可以指定vector为栈的底层实现，初始化语句如下：<br>
<code>std::stack&lt;int, std::vector&lt;int&gt; &gt; third;  // 使用vector为底层容器的栈</code><br>
队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, SGI STL中队列一样是以deque为缺省情况下的底部结构。<br>
<code>std::queue&lt;int, std::list&lt;int&gt;&gt; third; // 定义以list为底层容器的队列</code></p>
<p>###<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">用栈实现队列</a><br>
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>
int pop() 从队列的开头移除并返回元素<br>
int peek() 返回队列开头的元素<br>
boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
<p>两个栈一个负责入队，一个负责出队；<br>
因为栈是先进先出，利用两个栈进行翻转就能实现队列先进后出。</p>
<pre><code class="language-C++">class MyQueue {
public:
    stack&lt;int&gt; sin;
    stack&lt;int&gt; sout;
    MyQueue() {

    }
    
    void push(int x) {
        sin.push(x);
    }
    
    int pop() {
        if(sout.empty())
        {
            while(!sin.empty())
            {
                int tmp=sin.top();
                sin.pop();
                sout.push(tmp);
            }
        }
        int ans=sout.top();
        sout.pop();
        return ans;
    }
    
    int peek() {
        int tmp=this-&gt;pop();
        sout.push(tmp);
        return tmp;
    }
    
    bool empty() {
        return sin.empty()&amp;&amp;sout.empty();
    }
};
</code></pre>
<h3 id="用队列实现栈"><a href="https://leetcode.cn/problems/implement-stack-using-queues/">用队列实现栈</a></h3>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>
int pop() 移除并返回栈顶元素。<br>
int top() 返回栈顶元素。<br>
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<p>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。不一定要两个队列。</p>
<pre><code class="language-C++">class MyStack {
public:
    queue&lt;int&gt; qs;
    MyStack() {

    }
    
    void push(int x) {
        qs.push(x);
    }
    
    int pop() {
        for(int i=0;i&lt;qs.size()-1;i++)
        {
            int tmp = qs.front();
            qs.pop();
            qs.push(tmp);
        }
        int ans=qs.front();
        qs.pop();
        return ans;
    }
    
    int top() {
        return qs.back();
    }
    
    bool empty() {
        return qs.empty();
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[正则表达式]]></title>
        <id>https://moyihust.github.io/post/zheng-ze-biao-da-shi/</id>
        <link href="https://moyihust.github.io/post/zheng-ze-biao-da-shi/">
        </link>
        <updated>2023-10-20T09:27:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="正则表达式快速入门">正则表达式快速入门</h1>
<p>这种快速入门可以让您快速熟悉正则表达式。显然，这个简短的介绍无法解释有关正则表达式的所有知识。有关详细信息，请参阅<a href="https://www.regular-expressions.info/tutorial.html">正则表达式教程</a>。快速入门中的每个主题都与教程中的一个主题相对应，因此您可以轻松地在两者之间来回切换。</p>
<p>许多应用程序和编程语言都有自己的正则表达式实现，通常与其他实现有细微的差异，有时甚至有显着的差异。当两个应用程序使用不同的正则表达式实现时，我们说它们使用不同的“正则表达式风格”。本快速入门解释了最流行的正则表达式风格支持的语法。</p>
<h2 id="文本模式和匹配">文本模式和匹配</h2>
<p>正则表达式（或简称正则表达式）是描述一定量文本的模式。在此网站上，正则表达式以灰色显示为 regex 。这实际上是一个完全有效的正则表达式。这是最基本的模式，只需匹配文字文本 regex 。本网站上的比赛以蓝色突出显示。我们使用术语“字符串”来表示正则表达式所应用的文本。字符串在 green 中突出显示。</p>
<p>正则表达式中具有特殊含义的字符会以各种不同的颜色突出显示。正则表达式 (?x)([Rr]egexp?)\? 以紫色显示元标记，以绿色显示分组，以橙色显示字符类，以蓝色显示量词和其他特殊标记，以灰色显示转义字符。</p>
<h2 id="文字字符">文字字符</h2>
<p>最基本的正则表达式由单个文字字符组成，例如 a 。它匹配该字符在字符串中的第一次出现。如果字符串是 Jack is a boy ，则它与 J 之后的 a 匹配。<br>
此正则表达式也可以匹配第二个 a 。仅当您告诉正则表达式引擎在第一个匹配后开始搜索字符串时，它才会这样做。在文本编辑器中，您可以使用其“查找下一个”或“向前搜索”功能来执行此操作。在编程语言中，通常有一个单独的函数，您可以调用该函数来在上一个匹配之后继续搜索字符串。<br>
正则表达式中十二个字符具有特殊含义：反斜杠 \ 、脱字号 ^ 、美元符号 $ 、句点或点 . 、竖线或竖线符号 | 、问号 ? 、星号或星号 * 、加号 + 、左括号 ( 、右括号 ) 、左方括号[ 和左大括号 { 。这些特殊字符通常称为“元字符”。其中大多数在单独使用时都是错误的。<br>
如果您想在正则表达式中使用任何这些字符作为文字，则需要使用反斜杠对其进行转义。如果您想匹配 1+1=2 ，正确的正则表达式是 1+1=2 。否则，加号具有特殊含义。</p>
<h2 id="不可打印字符">不可打印字符</h2>
<p>可以使用特殊字符序列将不可打印的字符放入正则表达式中。使用 \t 匹配制表符（ASCII 0x09），\r 匹配回车符 （0x0D），\n 匹配换行符 （0x0A）。更奇特的不可打印是\a（bell，0x07），\e（escape，0x1B），\f（表单馈送，0x0C）和\v（垂直制表符，0x0B）。请记住，Windows 文本文件使用 \r\n 终止行，而 UNIX 文本文件使用\ \n。</p>
<p>如果您的应用程序支持 Unicode，请使用 \uFFFF 或 \x{FFFF} 插入 <a href="https://www.regular-expressions.info/unicode.html">Unicode</a> 字符。\u20AC 或 \x{20AC} 与欧元货币符号匹配。</p>
<p>如果应用程序不支持 Unicode，请使用 \xFF 通过字符集中的十六进制索引匹配特定字符。\xA9 与拉丁语 1 字符集中的版权符号匹配。</p>
<p>所有不可打印的字符都可以直接在正则表达式中使用，也可以作为字符类的一部分使用。</p>
<h2 id="字符类或字符集">字符类或字符集</h2>
<p>“字符类”仅匹配多个字符中的一个。要匹配 a 或 e，请使用 [ae]。你可以在gr[ae]y中使用它来匹配灰色或灰色。字符类仅与单个字符匹配。gr[ae]y与Graay，Graey或任何类似的东西不匹配。 字符类中字符的顺序无关紧要。</p>
<p>可以在字符类中使用连字符来指定字符范围。[0-9] 匹配 0 到 9 之间的一位数字。您可以使用多个范围。[0-9 a-fA-F] 匹配单个十六进制数字，不区分大小写。您可以组合范围和单个字符。[0-9 a-fxA-F X] 匹配十六进制数字或字母 X。</p>
<p>在左方括号后键入插入符号将否定字符类。结果是字符类匹配不在字符_类中的任何字符_。q[^x] 匹配有问题的 qu。它与伊拉克_不匹配_，因为 q 后面没有要匹配的否定字符类的字符。</p>
<h2 id="速记字符类">速记字符类</h2>
<p>\d 匹配作为数字的单个字符，\w 匹配“单词字符”（字母数字字符加下划线），\s 匹配空格字符（包括制表符和换行符）。速记匹配的实际字符取决于您使用的软件。在现代应用程序中，它们包括非英语字母和数字。</p>
<h2 id="圆点几乎匹配任何字符">圆点（几乎）匹配任何字符</h2>
<p>点匹配单个字符，换行符除外。大多数应用程序都有“点匹配所有”或“单行”模式，使点匹配任何单个字符，包括换行符。<br>
gr.y 匹配 gray 、 grey 、 gr%y 等。请谨慎使用点。通常，字符类或否定字符类更快、更精确。</p>
<h2 id="锚">锚</h2>
<p>锚点不匹配任何字符。他们匹配一个位置。 ^ 匹配字符串的开头， $ 匹配字符串的结尾。大多数正则表达式引擎都有“多行”模式，使 ^ 在任何换行符之后匹配，并在任何换行符之前匹配 $ 。例如。 ^b 仅匹配 bob 中的第一个 b 。<br>
\b 匹配单词边界。单词边界是 \w 可以匹配的字符和\ \w 不能匹配的字符之间的位置。如果字符串中的第一个和/或最后一个字符是单词字符， \b 也会在字符串的开头和/或结尾匹配。 \B 匹配 \b 无法匹配的每个位置。</p>
<h2 id="交替">交替</h2>
<p>交替是正则表达式中的“or”等价物。 cat|dog 匹配 About cats and dogs 中的 cat 。如果再次应用正则表达式，它会匹配 dog 。您可以根据需要添加任意多个替代方案： cat|dog|mouse|fish 。</p>
<p>在所有正则表达式运算符中，交替的优先级最低。 cat|dog food 匹配 cat 或 dog food 。要创建匹配 cat food 或 dog food 的正则表达式，您需要对替代项进行分组： (cat|dog) food 。</p>
<h2 id="重复">重复</h2>
<p>问号使正则表达式中的前面的标记成为可选的。 colou?r 匹配 colour 或 color 。<br>
星号或星号告诉引擎尝试匹配前面的标记零次或多次。加号告诉引擎尝试匹配前面的标记一次或多次。 &lt;[A-Za-z][A-Za-z0-9]*&gt; 匹配不带任何属性的 HTML 标记。 &lt;[A-Za-z0-9]+&gt; 更容易编写，但会匹配无效标签，例如 &lt;1&gt; 。<br>
使用花括号指定特定的重复次数。使用 \b[1-9][0-9]{3}\b 匹配 1000 到 9999 之间的数字。 \b[1-9][0-9]{2,4}\b 匹配 100 到 99999 之间的数字。</p>
<h2 id="贪婪和懒惰的重复">贪婪和懒惰的重复</h2>
<p>重复运算符或量词是贪婪的。他们尽可能地扩展匹配，并且只有在必须满足正则表达式的其余部分时才进行回馈。正则表达式 &lt;.+&gt; 与This is a &lt;EM&gt;first&lt;/EM&gt; test 中的&lt;EM&gt;first&lt;/EM&gt; 匹配。<br>
在量词后面加一个问号以使其变得懒惰。 &lt;.+?&gt; 与上述字符串中的 &lt;EM&gt; 匹配。<br>
更好的解决方案是遵循我的建议，谨慎使用点。使用 &lt;[^&lt;&gt;]+&gt; 快速匹配 HTML 标记，而不考虑属性。否定字符类比点更具体，这有助于正则表达式引擎快速找到匹配项。</p>
<h2 id="grouping-and-capturing-分组和捕获">Grouping and Capturing 分组和捕获</h2>
<p>将多个标记放在括号中以将它们组合在一起。然后您可以将量词应用于该组。例如。 Set(Value)? 匹配 Set 或 SetValue 。<br>
括号创建一个捕获组。上面的例子有一组。匹配后，如果 Set 匹配，则第一组不包含任何内容。如果 SetValue 匹配，它包含 Value 。如何访问该组的内容取决于您使用的软件或编程语言。组零始终包含整个正则表达式匹配。<br>
使用特殊语法 Set(?:Value)? 对标记进行分组，而无需创建捕获组。如果您不打算使用该组的内容，这会更有效。不要将非捕获组语法中的问号与量词混淆。</p>
<h2 id="backreferences-反向引用">Backreferences 反向引用</h2>
<p>在正则表达式中，您可以使用反向引用 \1 来匹配与捕获组匹配的相同文本。 ([abc])=\1 匹配 a=a 、 b=b 和 c=c 。它与其他任何东西都不匹配。如果您的正则表达式有多个捕获组，则会从左到右对它们的左括号进行编号。</p>
<h2 id="named-groups-and-backreferences-命名组和反向引用">Named Groups and Backreferences  命名组和反向引用</h2>
<p>如果您的正则表达式有很多组，那么跟踪它们的数量可能会很麻烦。通过命名您的组，使您的正则表达式更易于阅读。 (?&lt;mygroup&gt;[abc])=\k&lt;mygroup&gt; 与 ([abc])=\1 相同，只是您可以通过名称引用该组。</p>
<h2 id="unicode-properties-统一码属性">Unicode Properties 统一码属性</h2>
<p>\p{L} 匹配给定 Unicode 类别中的单个字符。 L 代表字母。 \P{L} 匹配不属于给定 Unicode 类别的单个字符。您可以在教程中找到 Unicode 类别的完整列表。</p>
<h2 id="lookaround-环视四周">Lookaround 环视四周</h2>
<p>Lookaround 是一个特殊的群体。组内的标记正常匹配，但正则表达式引擎使该组放弃匹配并仅保留结果。 Lookaround 匹配一个位置，就像锚点一样。它不会扩展正则表达式匹配。<br>
q(?=u) 与 question 中的 q 匹配，但与 Iraq 中的 q 不匹配。这是积极的前瞻。 u 不是整个正则表达式匹配的一部分。前瞻匹配字符串中 u 之前的每个位置。<br>
q(?!u) 与 Iraq 中的 q 匹配，但与 question 中不匹配。这是消极的前瞻。尝试先行内的标记，丢弃它们的匹配，并且将结果反转。<br>
要向后查看，请使用lookbehind。正向回顾 (?&lt;=a)b 与 abc 中的 b 匹配。负向查找 (?&lt;!a)b 无法匹配 abc 。<br>
您可以在前瞻中使用成熟的正则表达式。大多数应用程序只允许在lookbehind 中使用固定长度的表达式。</p>
<h2 id="free-spacing-syntax-自由间距语法">Free-Spacing Syntax 自由间距语法</h2>
<p>许多应用程序都有一个可能被标记为“自由间距”或“忽略空格”或“注释”的选项，该选项使正则表达式引擎忽略未转义的空格和换行符，并使#字符开始运行直到结束的注释。线。这允许您使用空格来格式化正则表达式，使人们更容易阅读，从而更容易维护。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[操作系统(1）概述]]></title>
        <id>https://moyihust.github.io/post/cao-zuo-xi-tong-1gai-shu/</id>
        <link href="https://moyihust.github.io/post/cao-zuo-xi-tong-1gai-shu/">
        </link>
        <updated>2023-10-19T02:17:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="cpu的态">CPU的态</h3>
<ul>
<li>用户态
<ul>
<li>有限的指令</li>
</ul>
</li>
<li>核态
<ul>
<li>全部指令</li>
<li>最高权限</li>
</ul>
</li>
<li>用户态向核态
<ul>
<li>用户请求os提供服务</li>
<li>发生错误</li>
<li>发生中断</li>
</ul>
<h3 id="存储体系">存储体系</h3>
<ul>
<li>实际体系
<ul>
<li>寄存器</li>
<li>高速缓存</li>
<li>主存</li>
<li>磁盘</li>
</ul>
</li>
</ul>
<h3 id="中断机制">中断机制</h3>
<ul>
<li>定义
<ul>
<li>指CPU对突发的外部信号的反应过程或机制</li>
<li>CPU收到外部信号后，停止当前操作，处理外部事件，处理完回到原来工作的中断处。</li>
</ul>
</li>
</ul>
</li>
<li>中断源
<ul>
<li>引发中断的事件</li>
</ul>
</li>
<li>中断类型
<ul>
<li>强迫中断和自愿中断
<ul>
<li>强迫：程序没预期，（外部中断</li>
<li>自愿：程序有预期。（int 21h 访管指令)</li>
</ul>
</li>
<li>外中断，内中断
<ul>
<li>外：外部事件引起，I/O
<ul>
<li>不可屏蔽中断：中断原因很紧要，CPU必须相应</li>
<li>可屏蔽中断：CPU可以选择响应</li>
</ul>
</li>
<li>内：内部事件引起</li>
</ul>
</li>
</ul>
</li>
<li>断点
<ul>
<li>程序中断的地方
<ul>
<li>将要执行的下一条指令位置(CS:IP)</li>
</ul>
</li>
</ul>
</li>
<li>现场
<ul>
<li>程序正确运行所依赖的信息集合
<ul>
<li>PSW（程序状态字），相关寄存器，断点</li>
</ul>
</li>
</ul>
</li>
<li>现场处理
<ul>
<li>保护：状态-&gt;栈</li>
<li>恢复：栈-&gt;状态</li>
</ul>
</li>
<li>中断响应过程
<ol>
<li>中断信号</li>
<li>断电入栈</li>
<li>现场入栈</li>
<li>进入中断服务</li>
<li>现场出栈</li>
<li>中断返回</li>
</ol>
</li>
<li>中断程序</li>
<li>填写中断向量表</li>
<li>填写中断描述符表</li>
<li>中断嵌套处理
<ul>
<li>高优先级打断低优先级中断服务</li>
</ul>
</li>
<li>中断响应的实质
<ul>
<li>交换指令执行的地址</li>
<li>交换CPU的态</li>
<li>工作
<ul>
<li>现场保护和恢复</li>
<li>参数传递</li>
</ul>
</li>
<li>引入中断的目的
<ul>
<li>实现并发</li>
<li>实现实时处理</li>
<li>故障自动处理</li>
</ul>
</li>
</ul>
<h3 id="bios">BIOS</h3>
<ul>
<li>系统BIOS
<ul>
<li>固件</li>
</ul>
</li>
</ul>
</li>
<li>功能
<ul>
<li>加电自检
<ul>
<li>初始化基本硬件</li>
<li>自检错误通过喇叭鸣叫</li>
<li>按下PowerON开始执行POST</li>
<li>计算首条指令在<em>FFFF0</em>单元</li>
<li><code>JMP POST</code></li>
</ul>
</li>
<li>设置CMOS</li>
<li>基本I/O功能</li>
<li>post之后
<ul>
<li>依次查找其他设备并初始化
<ul>
<li>查找显卡，执行显卡BIOS</li>
<li>查找IDE控制器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mode">mode</h3>
</li>
<li>实模式
<ul>
<li>按照8086访问1MB空间</li>
<li>寻址方式：物理地址（20）=段地址：偏移地址</li>
<li>CPU单任务运行</li>
</ul>
</li>
<li>保护模式
<ul>
<li>寻址方式：断（16bit）和偏移量，寻址4gb</li>
<li>CPU支持多任务</li>
</ul>
<h3 id="启动过程">启动过程</h3>
</li>
</ul>
<ol>
<li>初始引导
<ul>
<li>把OS内核装入内存并使之接管计算机系统</li>
<li>引导程序：MBR</li>
</ul>
</li>
<li>核心初始化
<ul>
<li>OS内核准备数据.</li>
</ul>
</li>
<li>系统初始化</li>
</ol>
<ul>
<li>为用户使用系统作准备</li>
</ul>
<h3 id="mbr">MBR</h3>
<ul>
<li>主启动扇区</li>
<li>存放引导代码
<ul>
<li>启动相关的数据和代码
<ul>
<li>512B=510字节+AA55h</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代码随想录day9]]></title>
        <id>https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day9/</id>
        <link href="https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day9/">
        </link>
        <updated>2023-10-19T01:47:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="字符串2">字符串2</h2>
]]></content>
    </entry>
</feed>