<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>汇编 | moyihust的小站</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://moyihust.github.io/favicon.ico?v=1709003230734">
<link rel="stylesheet" href="https://moyihust.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="汇编
汇编语言基础
微型计算机系统

主存空间的分配


8086CPU地址线是20位，最大寻址空间为 1MB，范围是00000H~FFFFFH,分为4个区段


基本RAM区(00000H~9FFFFH )

640KB，由DOS管理，操..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://moyihust.github.io">
        <img src="https://moyihust.github.io/images/avatar.png?v=1709003230734" class="site-logo">
        <h1 class="site-title">moyihust的小站</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://moyihust.github.io/post/moyihust" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://moyihust.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">汇编</h2>
            <div class="post-date">2023-10-20</div>
            
            <div class="post-content" v-pre>
              <h1 id="汇编">汇编</h1>
<h2 id="汇编语言基础">汇编语言基础</h2>
<h3 id="微型计算机系统">微型计算机系统</h3>
<ul>
<li>主存空间的分配
<ul>
<li>
<p>8086CPU地址线是20位，最大寻址空间为 1MB，范围是00000H~FFFFFH,分为4个区段</p>
<ul>
<li>
<p>基本RAM区(00000H~9FFFFH )</p>
<ul>
<li>640KB，由DOS管理，操作系统占用一部分低地址空间，剩下开放给用户程序</li>
</ul>
</li>
<li>
<p>保留RAM区(A0000H~BFFFFH)</p>
<ul>
<li>128KB，给系统安排的显示缓冲存储区，由显卡RAM芯片提供，用于存放屏幕显示信息，没有全部使用</li>
</ul>
</li>
<li>
<p>拓展ROM(C0000H~DFFFFH)</p>
<ul>
<li>128KB,由I/O接口卡的ROM芯片支持，给外设安排驱动程序</li>
</ul>
</li>
<li>
<p>系统ROM区(E0000H~FFFFFH)</p>
<ul>
<li>128KB,系统占用，提供BIOS(基本输入输出程序)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8086微处理器">8086微处理器</h3>
<ul>
<li>
<p>8086的结构功能</p>
<ul>
<li>
<p>内部结构</p>
</li>
<li>
<p>结构功能</p>
<ul>
<li>
<p>右半部分</p>
<ul>
<li>
<p>总线接口单元BIU</p>
</li>
<li>
<p>构成</p>
<ul>
<li>
<p>6字节的指令队列</p>
</li>
<li>
<p>指令指针</p>
</li>
<li>
<p>段寄存器</p>
<ul>
<li>
<p>CS</p>
<ul>
<li>代码段寄存器</li>
</ul>
</li>
<li>
<p>DS</p>
</li>
<li>
<p>SS</p>
</li>
<li>
<p>ES</p>
</li>
</ul>
</li>
<li>
<p>地址加法器</p>
</li>
<li>
<p>总线控制逻辑</p>
</li>
</ul>
</li>
<li>
<p>功能</p>
<ul>
<li>管理8086与外部总线的接口</li>
<li>负责CPU对存储器和外设的访问</li>
</ul>
</li>
</ul>
</li>
<li>
<p>左半部分</p>
<ul>
<li>
<p>执行单元EU</p>
</li>
<li>
<p>构成</p>
<ul>
<li>
<p>算术逻辑单元ALU</p>
</li>
<li>
<p>数据寄存器</p>
<ul>
<li>存放数据</li>
</ul>
</li>
<li>
<p>地址寄存器</p>
<ul>
<li>存放地址</li>
</ul>
</li>
<li>
<p>标志寄存器</p>
</li>
<li>
<p>指令译码的EU控制逻辑</p>
</li>
</ul>
</li>
<li>
<p>功能</p>
<ul>
<li>指令的译码执行</li>
<li>数据的运算</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>完成一条指令的过程</p>
<ul>
<li>
<p>取指</p>
<ul>
<li>
<p>从主存储器中取出指令代码进入CPU</p>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>提供指令地址</p>
<ul>
<li>由代码段寄存器CS和指令指针寄存器IP共同提供，由地址加法器得到20位存储器地址</li>
</ul>
</li>
<li>
<p>取出指令代码</p>
<ul>
<li>由总线接口单元BIU从存储器取出指令代码，送入指令队列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>执行</p>
<ul>
<li>
<p>将指令代码翻译成它代表的功能，即译码</p>
</li>
<li>
<p>细节</p>
<ul>
<li>
<p>取出指令代码</p>
</li>
<li>
<p>译码发出控制型号</p>
</li>
<li>
<p>进行数据运算和数据传送</p>
<ul>
<li>算术逻辑单元</li>
</ul>
</li>
<li>
<p>操作数据来源</p>
<ul>
<li>CPU内部寄存器，指令队列，存储器和外设（由EU控制BIU从外部获取）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的寄存器</p>
<ul>
<li>
<p>寄存器</p>
<ul>
<li>
<p>处理器内部的高速存储单元，用于暂存程序执行过程中的代码和数据</p>
</li>
<li>
<p>分类</p>
<ul>
<li>
<p>透明寄存器</p>
<ul>
<li>不可见，不能直接控制的寄存器</li>
<li>如保存指令代码的指令寄存器</li>
<li>透明指实际存在但是从某个角度看好像没有，即向上抽象</li>
</ul>
</li>
<li>
<p>可编程寄存器</p>
<ul>
<li>
<p>可以被程序员使用的寄存器，具有引用名称</p>
</li>
<li>
<p>分类</p>
<ul>
<li>
<p>通用寄存器</p>
<ul>
<li>数量较多，使用频率高，用来存放操作数据，地址</li>
</ul>
</li>
<li>
<p>专用寄存器</p>
<ul>
<li>用于特定目的，如指针寄存器IP记录执行指令的在地址，标志寄存器保存指令执行的辅助信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的寄存器组</p>
<ul>
<li></li>
<li>
<p>结构</p>
<ul>
<li>
<p>8个通用寄存器</p>
<ul>
<li>
<p>通用寄存器是多用途的，但在8086有它们各自的租用</p>
</li>
<li>
<p>数据寄存器</p>
<ul>
<li>
<p>可以分成高字节H和低字节L，如AX可以分为AH和AL</p>
</li>
<li>
<p>AX(Accumulator)</p>
<ul>
<li>
<p>累加器</p>
<ul>
<li>频率最高，用来算数和逻辑运算</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BX(Base)</p>
<ul>
<li>
<p>基址寄存器</p>
<ul>
<li>存放地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CX(Counter)</p>
<ul>
<li>
<p>计数器</p>
<ul>
<li>作为循环操作的计数器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DX(Data)</p>
<ul>
<li>
<p>数据寄存器</p>
<ul>
<li>存放数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变址寄存器</p>
<ul>
<li>
<p>有些指令有两个操作数，原操作数指参与运算的操作数，目的操作数是运算结果的操作数</p>
</li>
<li>
<p>SI(Source Index)</p>
<ul>
<li>
<p>原变址寄存器</p>
<ul>
<li>指向字符串或数组的原操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DI(Destination Index)</p>
<ul>
<li>
<p>目的变址寄存器</p>
<ul>
<li>指向字符串或数组的目的操作数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指针寄存器</p>
<ul>
<li>
<p>BP(Base Pointer)</p>
<ul>
<li>
<p>基址指针寄存器</p>
<ul>
<li>指向堆栈区域</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SP(Stack Pointer)</p>
<ul>
<li>
<p>堆栈指针寄存器</p>
<ul>
<li>指向堆栈顶部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>4个段寄存器</p>
<ul>
<li>
<p>代码段寄存器CS</p>
<ul>
<li>存放指令代码</li>
</ul>
</li>
<li>
<p>堆栈段寄存器SS</p>
<ul>
<li>指明程序使用的堆栈区域</li>
</ul>
</li>
<li>
<p>数据段寄存器DS</p>
<ul>
<li>存放当前程序所用数据</li>
</ul>
</li>
<li>
<p>附加段寄存器ES</p>
</li>
</ul>
</li>
<li>
<p>1个标志寄存器</p>
<ul>
<li>
<p>标志(flag)</p>
<ul>
<li>用于反映执行结果或控制指令执行形式</li>
</ul>
</li>
<li>
<p>标志寄存器(FLAGS)/程序状态字寄存器(PSW)</p>
<ul>
<li>各种常用标志组成的16位寄存器，其中有6位状态标志和3位控制标志</li>
<li></li>
</ul>
</li>
<li>
<p>状态标志</p>
<ul>
<li>
<p>最基本的标志，用来记录指令执行结果的辅助信息</p>
</li>
<li>
<p>CF(Carry Flag)</p>
<ul>
<li>进位标志</li>
</ul>
</li>
<li>
<p>PF(Parity Flag)</p>
<ul>
<li>奇偶标志</li>
</ul>
</li>
<li>
<p>AF(Adjust Flag)</p>
<ul>
<li>调整标志</li>
</ul>
</li>
<li>
<p>ZF(Zero Flag)</p>
<ul>
<li>零标志</li>
</ul>
</li>
<li>
<p>SF(Sign Flag)</p>
<ul>
<li>符号标志</li>
</ul>
</li>
<li>
<p>OF(Overflow Flag)</p>
<ul>
<li>溢出标志</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制标志</p>
<ul>
<li>
<p>控制执行指令的方式</p>
</li>
<li>
<p>DF(Direction Flag)</p>
<ul>
<li>
<p>方向标志</p>
<ul>
<li>用于串操作指令</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IF(Interruptenable Flag)</p>
<ul>
<li>
<p>中断允许标志</p>
<ul>
<li>控制中断是否可以被处理器处理</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TF(Trap Flag)</p>
<ul>
<li>
<p>陷阱标志/单步标志</p>
<ul>
<li>控制处理器是否进入单步操作方式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>1个指令指针寄存器</p>
<ul>
<li>
<p>IP(Instruction Pointer)</p>
<ul>
<li>
<p>指针寄存器</p>
<ul>
<li>存储执行指令的位置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>指针寄存器有自动增量的能力，每完成一个指令，IP就会自增，分支循环操作也会自动跳转</p>
</li>
</ul>
</li>
<li>
<p>这些寄存器均为16位</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的存储器组织</p>
<ul>
<li>
<p>数据的存储格式</p>
<ul>
<li>
<p>基本单位</p>
<ul>
<li>
<p>二进制位(bit)</p>
<ul>
<li>存储一个二进制位0或1</li>
</ul>
</li>
<li>
<p>字节(Byte)</p>
<ul>
<li>8个二进制位</li>
</ul>
</li>
<li>
<p>字(word)</p>
<ul>
<li>2个字节16位</li>
</ul>
</li>
<li>
<p>双字(Double Word)</p>
<ul>
<li>4字节32位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>特殊位</p>
<ul>
<li>
<p>最低有效位</p>
<ul>
<li>D0</li>
</ul>
</li>
<li>
<p>最高有效位</p>
<ul>
<li>D7 D15 D31</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存储单位</p>
<ul>
<li>字节</li>
</ul>
</li>
<li>
<p>存储单元内容</p>
<ul>
<li>通过[存储地址]来表示某个存储单元的内容</li>
<li>如[0002H] = 1234H</li>
</ul>
</li>
<li>
<p>地址对齐</p>
<ul>
<li>若存储器是n位的，多字节数据起始要从能够模n的数的地址开始</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存储器的分段管理</p>
<ul>
<li>
<p>1MB存储空间分为许多逻辑段，每个段都是16位，每个存储单元用 段基地址 : 段内偏移地址 表达准确物理位置</p>
</li>
<li>
<p>段基地址</p>
<ul>
<li>说明段基段在主存中起始位置，用 xxxx0H的形式表示，通常保存在段寄存器中</li>
</ul>
</li>
<li>
<p>段偏移地址</p>
<ul>
<li>说明主存单元距离起始位置的偏移量</li>
</ul>
</li>
<li>
<p>物理地址/绝对地址</p>
<ul>
<li>即唯一的20位地址</li>
</ul>
</li>
<li>
<p>逻辑地址</p>
<ul>
<li>即段地址:偏移地址的表达方式</li>
</ul>
</li>
<li>
<p>逻辑地址和物理地址的关系</p>
<ul>
<li>段地址左移4位加上偏移地址可以得到物理地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段寄存器的作用</p>
<ul>
<li>
<p>保存对应逻辑段的段基地址</p>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>代码段寄存器CS</p>
<ul>
<li>存放程序的指令序列，CS存放段地址，IP存放偏移地址，通过 CS:IP 获取执行指令</li>
</ul>
</li>
<li>
<p>堆栈段寄存器SS</p>
<ul>
<li>存放堆栈段的段地址， 堆栈指针寄存器SP存放栈顶偏移地址， 通过 SS : SP 操作堆栈的数据</li>
</ul>
</li>
<li>
<p>数据段寄存器DS</p>
<ul>
<li>存放数据段地址， 便宜地址由主存寻址方式得到</li>
</ul>
</li>
<li>
<p>附加段寄存器ES</p>
<ul>
<li>附加的数据顿啊，可以用于数据的保存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一些特点</p>
<ul>
<li>程序指令必须安排在代码段</li>
<li>堆栈一定在堆栈段中</li>
<li>数据默认安排在数据段，有时安排在附加段，尤其是串操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8086寻址方式">8086寻址方式</h3>
<ul>
<li>
<p>立即数寻址方式</p>
<ul>
<li>即常数</li>
<li>mov ax, 10h</li>
</ul>
</li>
<li>
<p>寄存器寻址方式</p>
<ul>
<li>用寄存器名</li>
<li>mov ax, bx</li>
</ul>
</li>
<li>
<p>存储器寻址方式</p>
<ul>
<li>
<p>用存储器地址</p>
</li>
<li>
<p>mov ax, [2000H]</p>
<ul>
<li>默认段为DS，即 DS:[2000H]</li>
</ul>
</li>
</ul>
</li>
<li>
<p>寄存器间接寻址方式</p>
<ul>
<li>
<p>通过使用寄存器内的内容访问存储器</p>
</li>
<li>
<p>mov ax, [di + 06h]</p>
<ul>
<li>若是di，默认段为DS</li>
<li>若是bp，默认段为SS</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有效地址EA</p>
<ul>
<li>即括号内所有之和</li>
</ul>
</li>
</ul>
<h2 id="8086的指令系统">8086的指令系统</h2>
<h3 id="数据传送类指令">数据传送类指令</h3>
<ul>
<li>
<p>通用数据创送指令</p>
<ul>
<li>
<p>传送指令mov</p>
<ul>
<li>
<p>将操作数从原地址 src 传送至 目的地址 dest</p>
</li>
<li>
<p>mov 目的 源</p>
<ul>
<li>
<p>限制</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>
<p>若16进制首位是字母，则要加0</p>
</li>
<li>
<p>指明操作类型</p>
<ul>
<li>
<p>字节操作</p>
<ul>
<li>byte ptr</li>
</ul>
</li>
<li>
<p>字操作</p>
<ul>
<li>word ptr</li>
</ul>
</li>
</ul>
</li>
<li>
<p>源和目的的类型必须一致，否则为非法指令</p>
</li>
<li>
<p>立即数不允许被移动到段寄存器里面</p>
</li>
<li>
<p>不允许存储单元移动到存储单元，中间要借助寄存器</p>
</li>
<li>
<p>不允许段寄存器之间直接数据传送</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>交换指令XCHG</p>
<ul>
<li>
<p>将源和目的的内容交换</p>
</li>
<li>
<p>xchg 目的 源</p>
<ul>
<li>
<p>限制</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>换码指令XLAT</p>
<ul>
<li>将BX指定的缓冲区，AL指定的位移赋值给AL</li>
</ul>
</li>
</ul>
</li>
<li>
<p>堆栈操作指令</p>
<ul>
<li>
<p>进栈指令PUSH</p>
<ul>
<li>将操作数压入栈，计算机自动操作SP指针减2</li>
<li>push 操作数</li>
</ul>
</li>
<li>
<p>出栈指令POP</p>
<ul>
<li>将栈顶的一个字弹到指定的操作数，堆栈指针SP自动加2</li>
<li>pop 操作数</li>
</ul>
</li>
<li>
<p>一些特点</p>
<ul>
<li>堆栈可以用来临时存放数据</li>
<li>堆栈是从最高地址往下堆</li>
</ul>
</li>
<li>
<p>堆栈的应用</p>
<ul>
<li>堆栈基址指针指向堆栈区域，以便于使用堆栈内部的数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志传送指令</p>
<ul>
<li>
<p>标志寄存器传送</p>
<ul>
<li>
<p>标志送AH指令LAHF</p>
<ul>
<li>将FLAGS的弟子皆传送给寄存器AH</li>
<li>lahf</li>
</ul>
</li>
<li>
<p>AH送标志指令 SAHF</p>
<ul>
<li>将AH寄存器内容传送给FLAGS低字节</li>
<li>sahf</li>
</ul>
</li>
<li>
<p>标志进栈指令PUSHF</p>
<ul>
<li>将标志寄存器的内容压入栈</li>
<li>pushf</li>
</ul>
</li>
<li>
<p>标志出栈指令POPF</p>
<ul>
<li>将栈顶内容创送至标志寄存器</li>
<li>popf</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志位操作</p>
<ul>
<li>
<p>设置进位</p>
<ul>
<li>
<p>0</p>
<ul>
<li>clc</li>
</ul>
</li>
<li>
<p>1</p>
<ul>
<li>stc</li>
</ul>
</li>
<li>
<p>～</p>
<ul>
<li>cmc</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置方向</p>
<ul>
<li>
<p>0</p>
<ul>
<li>cld</li>
</ul>
</li>
<li>
<p>1</p>
<ul>
<li>std</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置中断</p>
<ul>
<li>
<p>0</p>
<ul>
<li>cli</li>
</ul>
</li>
<li>
<p>1</p>
<ul>
<li>sti</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>地址传送指令</p>
<ul>
<li>
<p>有效地址传送指令LEA</p>
<ul>
<li>将操作数的有效地址传送给寄存器</li>
<li>lea 目的, 源</li>
</ul>
</li>
<li>
<p>指针传送指令LDS/LES</p>
<ul>
<li>
<p>LDS</p>
<ul>
<li>将主存的连续4个字节作为地址分别放到寄存器和DS</li>
</ul>
</li>
<li>
<p>LES</p>
<ul>
<li>将主存的连续4个字节作为地址分别放到寄存器和ES</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="算术运算类指令">算术运算类指令</h3>
<ul>
<li>
<p>用来执行算术运算</p>
</li>
<li>
<p>状态标志</p>
<ul>
<li>
<p>进位标志CF</p>
<ul>
<li>当进行运算后，如果CF=1，则说明运算过程最高位出现了进位或借位，否则说明没有</li>
<li>是针对无符号数据，用来说明最高位进位超出范围</li>
</ul>
</li>
<li>
<p>溢出标志OF</p>
<ul>
<li>若运算后数据溢出，则OF=1</li>
<li>针对有符号数据，用来说明有符号运算溢出</li>
</ul>
</li>
<li>
<p>其他状态标志</p>
<ul>
<li>
<p>零标志ZF</p>
<ul>
<li>反映运算结果是否为0（若ZF = 1 则 运算结果为0）</li>
</ul>
</li>
<li>
<p>符号标志SF</p>
<ul>
<li>用来判断符号位，最高位为1则SF为1</li>
</ul>
</li>
<li>
<p>奇偶标志PF</p>
<ul>
<li>判断8位数中1的个数为奇数或偶数，若为奇数，则PF = 0，只反映最低8位的个数，不能进行16位或32位操作</li>
</ul>
</li>
<li>
<p>调整标志AF</p>
<ul>
<li>反映低半字节是否向高字节进位或借位，若有则AF = 1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>加法指令</p>
<ul>
<li>
<p>加法指令ADD</p>
<ul>
<li>
<p>add 目的,源</p>
<ul>
<li>
<p>将源操作数加上目的操作数并且把结果放在目的操作数</p>
</li>
<li>
<p>限制</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p>在进行运算后FLAGS值会发生相应变化</p>
</li>
</ul>
</li>
<li>
<p>带进位加法指令ADC</p>
<ul>
<li>
<p>adc 目的,源</p>
<ul>
<li>和add应用方法一样，但是最后要加上一个进位cf，一般用于多精度的计算，当上一个add有进位时，下8位用ads可以保证进位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>增量指令INC</p>
<ul>
<li>
<p>inc 目的</p>
<ul>
<li>对操作数加1（不影响CF标志）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>减法指令</p>
<ul>
<li>
<p>减法指令SUB</p>
<ul>
<li>
<p>sub 目的, 源</p>
<ul>
<li>用目的操作数减去源操作数并将结果赋值给目的操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>带借位减法指令SBB</p>
<ul>
<li>
<p>sbb 目的, 源</p>
<ul>
<li>使目的操作数减去源操作数的同时再减去借位CF，用于结合SUB指令实现多精度加减法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>减量指令DEC</p>
<ul>
<li>
<p>dec 目的</p>
<ul>
<li>对操作数减1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>求补指令NEG</p>
<ul>
<li>
<p>neg 目的</p>
<ul>
<li>对目的操作数求补</li>
</ul>
</li>
</ul>
</li>
<li>
<p>比较指令CMP</p>
<ul>
<li>
<p>cmp 目的, 源</p>
<ul>
<li>将目的操作数减去源操作数，影响标志，但是最后不把结果返回给目的操作数</li>
<li>可以用于比较大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>乘法指令</p>
<ul>
<li>
<p>无符号乘法指令MUL</p>
<ul>
<li>
<p>mul 源</p>
<ul>
<li>若源操作数是8位，则将al与源操作数相乘，并将结果放入ax中</li>
<li>若源操作数是16位，则将ax与原操作数相乘，并将结果的低字节放入ax中，高字节放入dx中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有符号数乘法指令IMUL</p>
<ul>
<li>
<p>imul 源</p>
<ul>
<li>和mul相同，但是是有符号相乘</li>
</ul>
</li>
</ul>
</li>
<li>
<p>乘法指令只有OF和CF的标志位有效，其他标志位不可预测</p>
</li>
</ul>
</li>
<li>
<p>除法指令</p>
<ul>
<li>
<p>无符号二进制数除法指令DIV</p>
<ul>
<li>
<p>div 源</p>
<ul>
<li>若源操作数是8位，则将ax与源操作相除，并将商放入al中,余数放入ah中</li>
<li>若源操作数是16位，则将ax,dx与原操作数相除，并将结果的商放入ax中，余数放入dx中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有符号二进制数除法指令IDIV</p>
<ul>
<li>
<p>idiv 源</p>
<ul>
<li>与div相同，但是有符号相除</li>
</ul>
</li>
</ul>
</li>
<li>
<p>被除数远大于除数时，会溢出，然后程序停止</p>
</li>
</ul>
</li>
<li>
<p>符号扩展指令</p>
<ul>
<li>
<p>当需要将一些低位数据与高位数据进行运算时，要先将低位数据扩张为高位数据，但是本身数据大小不能改变</p>
</li>
<li>
<p>无符号数据扩展</p>
<ul>
<li>直接在前面加0</li>
</ul>
</li>
<li>
<p>有符号数据扩展</p>
<ul>
<li>需要进行符号扩展，在前面加上符号位的值</li>
</ul>
</li>
<li>
<p>符号扩展指令</p>
<ul>
<li>
<p>8位扩展16位指令CBW</p>
<ul>
<li>将AL扩展到AX</li>
</ul>
</li>
<li>
<p>16位扩张32位指令CWD</p>
<ul>
<li>将AX扩展到DX</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>十进制调整指令</p>
<ul>
<li>
<p>压缩BCD码调整指令</p>
<ul>
<li>
<p>压缩BCD码</p>
<ul>
<li>通常的8421码，用4个二进制位表示一个十进制位，一字节可以表示两个二进制位</li>
</ul>
</li>
<li>
<p>压缩BCD码调整指令</p>
<ul>
<li>
<p>对二进制加减法指令的执行结果进行调整得到十进制结果，在执行他们之前要先执行加法或减法指令</p>
</li>
<li>
<p>加法十进制调整指令DAA</p>
<ul>
<li>
<p>daa</p>
<ul>
<li>在以al为目的操作数的add运算后，对al的二进制结果进行十进制调整，在al中得到十进制结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>减法十进制调整指令DAS</p>
<ul>
<li>
<p>das</p>
<ul>
<li>和daa一样，不过是跟在sub之后</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对OF标志位无定义，影响其他所有标志，CF反映BCD码的进位状态</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非压缩BCD码调整指令</p>
<ul>
<li>
<p>非压缩BCD码</p>
<ul>
<li>用8个二进制为表示一个十进制位，即用ASCII编码表示十进制位</li>
</ul>
</li>
<li>
<p>非压缩BCD码调整指令</p>
<ul>
<li>
<p>加法非压缩BCD调整指令AAA</p>
<ul>
<li>aaa</li>
</ul>
</li>
<li>
<p>减法非压缩BCD码调整指令AAS</p>
<ul>
<li>aas</li>
</ul>
</li>
<li>
<p>乘法非压缩BCD码调整指令AAD</p>
<ul>
<li>aad</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="位操作类指令">位操作类指令</h3>
<ul>
<li>
<p>逻辑运算指令</p>
<ul>
<li>
<p>逻辑与指令 AND</p>
<ul>
<li>
<p>and 目的, 源</p>
<ul>
<li>对两个操作数执行按位与运算，将结果创送给目的操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑或指令 OR</p>
<ul>
<li>or 目的, 源</li>
</ul>
</li>
<li>
<p>逻辑异或指令 XOR</p>
<ul>
<li>xor 目的, 源</li>
</ul>
</li>
<li>
<p>逻辑非指令 NOT</p>
<ul>
<li>not 目的, 源</li>
</ul>
</li>
<li>
<p>测试指令 TEST</p>
<ul>
<li>
<p>test 目的, 源</p>
<ul>
<li>对两者进行与运算，但不把结果赋值给目的，保留标志位</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志位</p>
<ul>
<li>CF = OF = 0,其他标志位看结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>移位指令</p>
<ul>
<li>
<p>逻辑左移 SHL</p>
<ul>
<li>
<p>shl 目的, 1/cl</p>
<ul>
<li>将数据左移,若源是1，移动1位，若要移动多于1位，则用cl寄存器代替，最低位补0，最高位进入cf</li>
</ul>
</li>
</ul>
</li>
<li>
<p>逻辑右移 SHR</p>
<ul>
<li>
<p>shr 目的, 1/cl</p>
<ul>
<li>最高位补0，最低位进入cf</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算数左移 SAL</p>
<ul>
<li>
<p>sal 目的, 1/cl</p>
<ul>
<li>与逻辑左移相同</li>
</ul>
</li>
</ul>
</li>
<li>
<p>算数右移 SAR</p>
<ul>
<li>
<p>sar 目的, 1/cl</p>
<ul>
<li>补充的时候补充最高位的值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标志位</p>
<ul>
<li>CF和OF有定义，当移动次数大于1时，OF无定义，其他位全部无定义</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环移位指令</p>
<ul>
<li>类似移位指令，但从一段移出的位返回到另一端</li>
<li>不带进位循环左移 ROL</li>
<li>不带进位循环右移 ROR</li>
<li>带进位循环左移 RCL</li>
<li>带进位循环右移 RCR</li>
</ul>
</li>
</ul>
<h3 id="控制转移类指令">控制转移类指令</h3>
<ul>
<li>
<p>无条件转移指令 JMP</p>
<ul>
<li>
<p>段内转移，相对寻址</p>
<ul>
<li>
<p>jmp 8位或16位位移量</p>
<ul>
<li>IP = IP + 位移量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段内转移，间接寻址</p>
<ul>
<li>
<p>jmp 源</p>
<ul>
<li>IP = 源操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段间转移，直接寻址</p>
<ul>
<li>
<p>jmp far ptr 32位逻辑地址</p>
<ul>
<li>cs会变成到逻辑地址的段地址，ip会变成逻辑地址的偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段间转移，间接寻址</p>
<ul>
<li>
<p>jmp far ptr 主存地址</p>
<ul>
<li>将主存地址当做ip，该主存地址的高位当做段地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>条件转移指令 jcc</p>
<ul>
<li>
<p>jcc 8位位移量</p>
<ul>
<li>若条件满足，则ip加上位移量，否则加上2，进入下一条语句</li>
<li>cc代表利用标志判断条件</li>
</ul>
</li>
<li>
<p>判断满足条件</p>
<ul>
<li>
<p>常用满足条件</p>
<ul>
<li>
<p>等于0/不等于0</p>
<ul>
<li>
<p>jz/jnz</p>
<ul>
<li>标志位ZF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>符号为负/正</p>
<ul>
<li>
<p>js/jns</p>
<ul>
<li>标志位SF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>溢出</p>
<ul>
<li>
<p>jo</p>
<ul>
<li>标志位OF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>进位/无进位</p>
<ul>
<li>
<p>jc/jnc</p>
<ul>
<li>标志位CF</li>
</ul>
</li>
</ul>
</li>
<li>
<p>大于等于</p>
<ul>
<li>JNL</li>
</ul>
</li>
<li>
<p>小于等于</p>
<ul>
<li>JLE</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>循环指令</p>
<ul>
<li>
<p>jcxz 8位位移量</p>
<ul>
<li>cx为0则ip加上位移量，否则顺序执行</li>
</ul>
</li>
<li>
<p>loop 8位位移量</p>
<ul>
<li>先将cx减去1，若cx不为0，ip加上位移量，否则顺序执行</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序指令</p>
<ul>
<li>
<p>子程序调用指令CALL</p>
<ul>
<li>
<p>段内调用</p>
<ul>
<li>
<p>相对寻址</p>
<ul>
<li>
<p>call 十六位位移量</p>
<ul>
<li>先把当前ip地址压入栈，再将ip加上位移量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>间接寻址</p>
<ul>
<li>call 源</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段间调用</p>
<ul>
<li>
<p>直接寻址</p>
<ul>
<li>
<p>call far ptr 十六位位移量</p>
<ul>
<li>先把ip移入栈，再将cs换到位移量的段地址，ip换到位移量的偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>间接寻址</p>
<ul>
<li>call far ptr 主存地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序返回指令RET</p>
<ul>
<li>
<p>无参数返回</p>
<ul>
<li>
<p>ret</p>
<ul>
<li>将栈弹出给ip</li>
</ul>
</li>
</ul>
</li>
<li>
<p>有参数返回</p>
<ul>
<li>
<p>ret 十六位数据</p>
<ul>
<li>将栈弹出给ip, 并且将数据压入栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中断指令</p>
<ul>
<li>
<p>中断概念</p>
<ul>
<li>程序运行时遇到紧急情况时，当前程序会暂停，转去执行这些紧急情况的程序段</li>
</ul>
</li>
<li>
<p>8086的中断类型</p>
<ul>
<li>
<p>外部中断</p>
<ul>
<li>
<p>指来自cpu之外的原因引起的程序中断</p>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>可屏蔽中断</p>
<ul>
<li>
<p>指中断请求可以被cpu内部屏蔽</p>
</li>
<li>
<p>由标志寄存器中的IF控制</p>
<ul>
<li>在任何一个中断服务程序被执行后，或者执行关中断指令CLI后，IF=0，cpu屏蔽中断，称为关中断状态</li>
<li>当中断服务程序结束，执行中断返回指令IRET时，回复中断前IF状态</li>
</ul>
</li>
</ul>
</li>
<li>
<p>非屏蔽中断</p>
<ul>
<li>不受IF标志影响，CPU必须执行的指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>内部中断</p>
<ul>
<li>
<p>指CPU内部执行程序引起的程序中断，也称异常</p>
</li>
<li>
<p>类型</p>
<ul>
<li>
<p>除法错中断</p>
<ul>
<li>除数为0或者商超过寄存器能表达的范围，向量表中排号为0</li>
</ul>
</li>
<li>
<p>指令中断</p>
<ul>
<li>也叫软件中断，通过INT n产生指令中断，n是指令码，当n等于3，执行中断调用指令,常用作程序调试的断点中断，向量表中排号为3</li>
</ul>
</li>
<li>
<p>溢出中断</p>
<ul>
<li>执行溢出中断指令INTO，当OF为1，产生溢出中断，向量表中排号为4</li>
</ul>
</li>
<li>
<p>单步中断</p>
<ul>
<li>当单步标志TF为1时，每条指令执行完后都产生单步中断向量表中排号为1</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的中断过程</p>
<ul>
<li>
<p>中断服务程序</p>
<ul>
<li>中断服务程序可以被看成一个子程序，放在主存的任何位置，它的程序首地址被放在中断向量表中</li>
</ul>
</li>
<li>
<p>中断向量表</p>
<ul>
<li>设置在主存的最低1kb区域，物理地址为000H~3FFH，从0开始每4字节对应一个中断，低字节存放中断服务程序的偏移地址IP，高字节存放段地址CS</li>
</ul>
</li>
<li>
<p>中断处理过程</p>
<ul>
<li>先将标志寄存器压入栈</li>
<li>禁止中断过程有中断 ：IF = 0, TF = 0</li>
<li>将断点地址压入栈，先压入段地址，再压入偏移地址</li>
<li>读取中断服务程序的起始地址，进入中断服务程序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>8086的中断指令</p>
<ul>
<li>
<p>中断指令INT</p>
<ul>
<li>
<p>int 8位数据</p>
<ul>
<li>产生n号中断</li>
</ul>
</li>
</ul>
</li>
<li>
<p>中断返回指令IRET</p>
<ul>
<li>
<p>iret</p>
<ul>
<li>类似函数的ret，实现中断返回</li>
</ul>
</li>
</ul>
</li>
<li>
<p>溢出中断指令INTO</p>
<ul>
<li>
<p>into</p>
<ul>
<li>当溢出标志of为1时调用该指令，产生4号中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="处理机控制类指令">处理机控制类指令</h3>
<ul>
<li>
<p>作用</p>
<ul>
<li>用来控制各种CPU的操作，例如暂停，等待或空操作</li>
</ul>
</li>
<li>
<p>空操作指令NOP</p>
<ul>
<li>
<p>nop</p>
<ul>
<li>不执行任何有意义的操作，占用1字节存储单元，空号一个指令执行周期，常用于软件延时，它的执行和 XCHG AX,AX本质一样</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段超越SEG</p>
<ul>
<li>
<p>seg:</p>
<ul>
<li>seg就是段名，cs, ss, ds, es, 在允许段超越的存储器操作数之前，使用该指令可以采用指定的段寄存器寻址操作数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>封锁前缀指令LOCK</p>
<ul>
<li>
<p>lock</p>
<ul>
<li>执行后，在这个指令执行时间内，封锁输出引脚，即封锁总线，让别的控制器无法控制总线，可以用来避免破坏有用信息</li>
</ul>
</li>
</ul>
</li>
<li>
<p>暂停指令HLT</p>
<ul>
<li>
<p>hlt</p>
<ul>
<li>让CPU进入暂停状态，当CPU发生复位或外部中断时，脱离暂停状态，当程序需要等待中断时，使用该指令可以让软件不进入死循环，然后CPU通过中断脱离暂停，并执行hlt的吓一跳指令，该指令相当于死机，一般应用程序不要使用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>交权指令ESC</p>
<ul>
<li>
<p>esc 6位立即数, 寄存器或主存</p>
<ul>
<li>交权给外部协处理器，如浮点运算交给外部处理器8087</li>
</ul>
</li>
</ul>
</li>
<li>
<p>等待指令WAIT</p>
<ul>
<li>当8086测试输入引脚为高电平无效时，CPU进入等待状态，此时CPU不进行任何操作，测试为低电平有效时，继续执行指令，如交权给外部处理器时为了保持同步，8086应利用wait指令保持同步</li>
</ul>
</li>
</ul>
<h2 id="汇编语言程序格式">汇编语言程序格式</h2>
<h3 id="汇编语言程序的开发">汇编语言程序的开发</h3>
<ul>
<li>
<p>汇编语言程序的语句格式</p>
<ul>
<li>
<p>语句类型</p>
<ul>
<li>
<p>执行性语句</p>
<ul>
<li>标号: 处理器指令助记符 操作数, 操作数</li>
</ul>
</li>
<li>
<p>说明性语句</p>
<ul>
<li>名字 伪指令助记符 参数, 参数, ...</li>
</ul>
</li>
</ul>
</li>
<li>
<p>标号与名字</p>
<ul>
<li>
<p>标号</p>
<ul>
<li>在执行性语句中，&quot;:&quot;前面的标号表示处理器指令在主存中的逻辑地址，主要用于指示分支</li>
</ul>
</li>
<li>
<p>名字</p>
<ul>
<li>说明性语句中的名字反应变量，段和子程序的逻辑地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>助记符</p>
<ul>
<li>
<p>帮助记忆指令的符号，反映指令的功能</p>
</li>
<li>
<p>助记符db</p>
<ul>
<li>分配一段存储空间，保存变量值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>操作数和参数</p>
<ul>
<li>即源操作数，目的操作数等</li>
</ul>
</li>
<li>
<p>注释</p>
<ul>
<li>语句中 &quot; ; &quot; 之后的内容是注释</li>
</ul>
</li>
</ul>
</li>
<li>
<p>汇编语言的源程序框架</p>
<ul>
<li>
<p>.model small</p>
<ul>
<li>
<p>定义程序的存储模式</p>
<ul>
<li>small表示小型模式</li>
</ul>
</li>
</ul>
</li>
<li>
<p>.stack</p>
<ul>
<li>定义堆栈段</li>
</ul>
</li>
<li>
<p>,data</p>
<ul>
<li>定义数据段</li>
</ul>
</li>
<li>
<p>数据定义</p>
</li>
<li>
<p>.code</p>
<ul>
<li>定义代码段</li>
</ul>
</li>
<li>
<p>.startup</p>
<ul>
<li>程序起始点</li>
</ul>
</li>
<li>
<p>主程序代码</p>
</li>
<li>
<p>.exit 0</p>
<ul>
<li>程序终止点</li>
</ul>
</li>
<li>
<p>子程序代码</p>
</li>
<li>
<p>end</p>
<ul>
<li>汇编结束</li>
</ul>
</li>
</ul>
</li>
<li>
<p>汇编语言程序的开发过程</p>
<ul>
<li>
<p>先安装开发软件，MASM 6.x完全版</p>
<ul>
<li>
<p>MASM软件包文件</p>
<ul>
<li>
<p>主程序目录</p>
<ul>
<li>
<p>配置MASM的基本文件</p>
<ul>
<li>
<p>汇编程序</p>
<ul>
<li>ml.exe</li>
</ul>
</li>
<li>
<p>汇编错误信息文件</p>
<ul>
<li>ml.err</li>
</ul>
</li>
<li>
<p>连接程序</p>
<ul>
<li>link.exe</li>
</ul>
</li>
<li>
<p>子程序库管理文件</p>
<ul>
<li>lib.exe</li>
</ul>
</li>
</ul>
</li>
<li>
<p>含有作者创建的文件</p>
</li>
</ul>
</li>
<li>
<p>HELP目录</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DOS系统功能调用</p>
<ul>
<li>
<p>方法</p>
<ul>
<li>先在AH寄存器中设置系统功能调用号，说明选择功能</li>
<li>在指定的寄存器设置入口参数，以便系统执行功能</li>
<li>调用中断指令 INT 21H 执行功能调用</li>
</ul>
</li>
<li>
<p>基本功能调用</p>
<ul>
<li>
<p>输入字符</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 01H</li>
</ul>
</li>
<li>
<p>出口参数</p>
<ul>
<li>AL = 输入字符的ASCII码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输出字符</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 02H</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>DL = 输入字符的ASCII码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输出字符串</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 09H</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>DS:DX = 字符串的地址</li>
<li>通过 offset 字符串名字 来获取字符串的地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输入字符串</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 0AH</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>DS:DX = 缓冲区的地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>判断键盘是否输入</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 0BH</li>
</ul>
</li>
<li>
<p>出口参数</p>
<ul>
<li>AL = 0 :无, AL = FFH :有</li>
</ul>
</li>
</ul>
</li>
<li>
<p>终止程序</p>
<ul>
<li>
<p>功能号</p>
<ul>
<li>AH = 4CH</li>
</ul>
</li>
<li>
<p>入口参数</p>
<ul>
<li>AL = 返回代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="参数变量和标号">参数，变量和标号</h3>
<ul>
<li>
<p>数值型参数</p>
<ul>
<li>
<p>常数</p>
<ul>
<li>
<p>十进制</p>
<ul>
<li>以D结尾</li>
</ul>
</li>
<li>
<p>十六进制</p>
<ul>
<li>以H结尾</li>
</ul>
</li>
<li>
<p>二进制</p>
<ul>
<li>以B结尾</li>
</ul>
</li>
<li>
<p>八进制</p>
<ul>
<li>以Q结尾</li>
</ul>
</li>
</ul>
</li>
<li>
<p>字符串常数</p>
<ul>
<li>用单引号括起来的一个或多个字符，如 'string'</li>
</ul>
</li>
<li>
<p>符号常数</p>
<ul>
<li>
<p>利用一个标识符去表达一个常数</p>
<ul>
<li>符号名 equ 常数</li>
<li>符号名 equ &lt;字符串&gt;</li>
<li>符号名 = 常数</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>符号名 = 常数 可行，但是 符号名 = 符号名 + 常数不可行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量定义伪指令</p>
<ul>
<li>
<p>定义</p>
<ul>
<li>为变量分配固定长度的存储空间</li>
</ul>
</li>
<li>
<p>汇编格式</p>
<ul>
<li>变量名 伪指令 初值表</li>
</ul>
</li>
<li>
<p>解释</p>
<ul>
<li>
<p>变量名</p>
<ul>
<li>变量名代表了分配的逻辑地址，可以没有变量名，这种情况计算机仅仅分配地址</li>
</ul>
</li>
<li>
<p>初值表</p>
<ul>
<li>
<p>给分配的空间赋初值</p>
<ul>
<li>
<p>分配某确定初值</p>
<ul>
<li>初值表为 数值</li>
</ul>
</li>
<li>
<p>不确定初值</p>
<ul>
<li>初值表为 ？</li>
</ul>
</li>
<li>
<p>重复初值</p>
<ul>
<li>初值表为 重复次数 dup(重复参数)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>伪指令</p>
<ul>
<li>根据申请的主存空间单位分类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>伪指令类型</p>
<ul>
<li>
<p>定义字节单元伪指令DB</p>
<ul>
<li>分配1字节或多字节单元</li>
</ul>
</li>
<li>
<p>定义字单元伪指令DW</p>
<ul>
<li>分配1字(2字节)或多字单元</li>
</ul>
</li>
<li>
<p>定义双字单元伪指令DD</p>
<ul>
<li>分配一个或多个双字单环(4字节)</li>
</ul>
</li>
<li>
<p>定义3字伪指令DF</p>
</li>
<li>
<p>定义4字伪指令DQ</p>
</li>
<li>
<p>定义10字节伪指令DT</p>
</li>
<li>
<p>定位伪指令</p>
<ul>
<li>
<p>控制数据分配位置参数ORG</p>
<ul>
<li>
<p>org 100h</p>
<ul>
<li>在100h处分配空间</li>
</ul>
</li>
<li>
<p>org $+10</p>
<ul>
<li>将偏移地址+10后分配空间</li>
<li>$表示当前偏移地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>偶数化当前偏移地址参数EVEN</p>
<ul>
<li>
<p>even</p>
<ul>
<li>将当前偏移地址偶数化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对其偏移地址参数ALIGN</p>
<ul>
<li>
<p>align n</p>
<ul>
<li>以n的倍数对齐</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量与标号的属性</p>
<ul>
<li>
<p>标号和名字的属性</p>
<ul>
<li>
<p>地址属性</p>
<ul>
<li>标号和名字对应的存储单元的逻辑地址，包括段地址和偏移地址</li>
</ul>
</li>
<li>
<p>类型属性</p>
<ul>
<li>
<p>标号，子程序的类型</p>
<ul>
<li>near(近)/far(远)</li>
</ul>
</li>
<li>
<p>变量名类型</p>
<ul>
<li>byte,word,dword</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>地址操作符</p>
<ul>
<li>
<p>返回名字的标号或偏移地址</p>
<ul>
<li>offset 名字/标号</li>
</ul>
</li>
<li>
<p>返回名字或标号的段地址</p>
<ul>
<li>seg 名字/标号</li>
</ul>
</li>
</ul>
</li>
<li>
<p>类型操作符</p>
<ul>
<li>
<p>临时改变名字和标号的类型</p>
<ul>
<li>类型名 ptr 名字/标号</li>
</ul>
</li>
<li>
<p>分配当前地址给变量名，并且不将逻辑地址向后移动，相当于用两个变量名给同一个地址空间命名</p>
<ul>
<li>this 类型名</li>
<li>name equ this byte</li>
</ul>
</li>
<li>
<p>返回名字或标号的类型对应的数值</p>
<ul>
<li>
<p>TYPE 名字/标号</p>
</li>
<li>
<p>对应数值</p>
<ul>
<li>
<p>变量</p>
<ul>
<li>每个数据占用字节数</li>
</ul>
</li>
<li>
<p>标号</p>
<ul>
<li>逻辑地址</li>
</ul>
</li>
<li>
<p>结构</p>
<ul>
<li>每个结构元素占用的字节数</li>
</ul>
</li>
<li>
<p>寄存器</p>
<ul>
<li>该寄存器具有的字节数</li>
</ul>
</li>
<li>
<p>常数</p>
<ul>
<li>0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="程序段的定义和属性">程序段的定义和属性</h3>
<ul>
<li>
<p>DOS的程序结构</p>
<ul>
<li>
<p>EXE 程序</p>
<ul>
<li>
<p>exe程序的简介</p>
<ul>
<li>利用程序开发工具，所生成的可执行程序，拥有堆栈段，一个或多个的代码数据段，执行起始处可以任意指定</li>
</ul>
</li>
<li>
<p>exe文件在磁盘上的组成</p>
<ul>
<li>
<p>文件头</p>
<ul>
<li>
<p>生成</p>
<ul>
<li>由连接程序生成</li>
</ul>
</li>
<li>
<p>内容</p>
<ul>
<li>文件的控制信息</li>
<li>重定位信息</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>供DOS装入EXE文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>装入模块</p>
<ul>
<li>即程序本身</li>
</ul>
</li>
<li>
<p>附加部分(有些大型exe文件有)</p>
<ul>
<li>仅供程序本身使用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DOS装入或执行程序过程</p>
<ul>
<li>
<p>选择起始点作为程序段</p>
<ul>
<li>在这个过程中，DOS确定当时主存最低可用地址作为程序装入的起始点作为程序段</li>
</ul>
</li>
<li>
<p>生成程序段前缀块PSP</p>
<ul>
<li>在起始点生成一个256字节的程序段前缀控制块PSP（100H）</li>
</ul>
</li>
<li>
<p>装入程序本身</p>
<ul>
<li>将代码段，数据段，堆栈段...装在PSP上面</li>
</ul>
</li>
</ul>
</li>
<li>
<p>exe程序的加载</p>
<ul>
<li>
<p>重新定位</p>
<ul>
<li>将DS，ES指向PSP段地址</li>
<li>通过连接程序确定CS：IP和SS：SP的值</li>
<li>装载成功，开始执行IP指向的第一条指令</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>COM 程序</p>
<ul>
<li>
<p>COM程序的简介</p>
<ul>
<li>将代码数据和堆栈段合一的结构紧凑的程序，将所有代码数据都放在一个逻辑段里面，不超过64kb，在程序开发是需要满足一定条件并采用相应参数才能生成COM程序</li>
</ul>
</li>
<li>
<p>COM程序的特点</p>
<ul>
<li>在磁盘上是主存的完全影像，不包含定位加载信息，相比exe加载速度快，占用空间少</li>
</ul>
</li>
<li>
<p>COM程序的加载过程</p>
<ul>
<li>所有的段地址都指向PSP</li>
<li>IP=100H，即PSP后面一定要是可执行指令</li>
<li>堆栈区设置在段尾，栈底设置0000</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>简化段定义的格式</p>
<ul>
<li>
<p>存储模型伪指令</p>
<ul>
<li>
<p>作用</p>
<ul>
<li>决定一个程序的规模，确定了子程序的调用，指令转移和数据访问的默认属性</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li>,model 存储模型[语言类型][从操作系统类型][堆栈选项]</li>
</ul>
</li>
<li>
<p>存储模型</p>
<ul>
<li>
<p>微型模型TINY</p>
<ul>
<li>
<p>所有段地址寄存器被设置为同一值，代码段数据段堆栈段在同一个段内，总大小不大于64kb</p>
</li>
<li>
<p>作用</p>
<ul>
<li>用于创建COM类型程序</li>
</ul>
</li>
</ul>
</li>
<li>
<p>小型模型SMALL</p>
<ul>
<li>一个程序之多有一个代码段和一个数据段（包含数据段，堆栈段和附加段，它们公用一个段基址），每个段不大于64kb，所以最大长度为128kb</li>
<li>偏移地址用16位就可以访问所有空间，所以各种操作的数据范围都是近指针</li>
</ul>
</li>
<li>
<p>紧凑模型COMPACT</p>
<ul>
<li>代码段限制在64kb的段内，但是数据段可以有多个，超过64kb，这个模型数据指针默认为远指针，用于定位数据段，调用为近调用</li>
<li>用于数据量大但是代码量小的程序</li>
</ul>
</li>
<li>
<p>中型模型MEDIUM</p>
<ul>
<li>和紧凑模型互补，可以有多个代码段，都可以可以超过64kb，但是数据段只能有不大于64kb的段</li>
<li>适合数据量小但是代码量大的程序</li>
</ul>
</li>
<li>
<p>大型模型LARGE</p>
<ul>
<li>代码段和数据段都有多个，都可以超过64kb，但是静态数据依然限制在64kb内</li>
</ul>
</li>
<li>
<p>巨型模型HUGE</p>
<ul>
<li>相比于大型模型静态数据没有限制</li>
</ul>
</li>
<li>
<p>平展模型FLAT</p>
<ul>
<li>创建一个32位的程序，要使用32位x86处理器的伪指令</li>
<li>32位windows应用程序必须用FLAT模型，DOS不能使用该模型</li>
</ul>
</li>
<li>
<p>产生的文件</p>
<ul>
<li>TINY模型尝试COM文件，其他模型尝试EXE程序，FLAT模型只用于32位程序，高级语言混合编程时存储模型要一致</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>简化段定义伪指令</p>
<ul>
<li>
<p>定义</p>
<ul>
<li>
<p>语句.CODE .DATA .STACK分别表达数据段和堆栈段的开始</p>
<ul>
<li>在简化段定义指令之前必须有存储模型语句MODEL</li>
</ul>
</li>
</ul>
</li>
<li>
<p>堆栈段伪指令 .STACK</p>
<ul>
<li>.stack [大小]</li>
<li>创建一个堆栈段，参数指定堆栈段占的字节数，默认1KB</li>
</ul>
</li>
<li>
<p>数据段伪指令.DATA</p>
<ul>
<li>.data<br>
.data？</li>
<li>有初值变量定义在.data中，无初值变量定义在.data?中，这里面的数据是在程序运行后才分配空间</li>
</ul>
</li>
<li>
<p>代码段伪指令.CODE</p>
<ul>
<li>.code [段名]</li>
<li>创建一个代码段，参数指定改代码短的段名，如果没有给参数用默认段名，在TINY，SMALL，COMPACT，FLAT模型下默认段名是“_TEXT”，在大型的默认段名是“模块名_TEXT”</li>
</ul>
</li>
<li>
<p>程序开始伪指令.STARTUP</p>
<ul>
<li>.startup</li>
<li>按照cpu类型和选择的模型，操作系统和堆栈类型，产生开始执行的代码，同时指定程序开始的起始点。该语句初始化DS值，调整了SS和SP的值。</li>
</ul>
</li>
<li>
<p>程序终止伪指令.EXIT</p>
<ul>
<li>.exit [返回代码]</li>
<li>该语句产生终止程序的代码，参数为0表示没有错误</li>
</ul>
</li>
<li>
<p>汇编结束伪指令END</p>
<ul>
<li>end [标号]</li>
<li>表示汇编程序到此结束</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本汇编语言程序设计">基本汇编语言程序设计</h2>
<h3 id="循环程序设计">循环程序设计</h3>
<ul>
<li>
<p>串操作类指令</p>
<ul>
<li>
<p>操作数据串的指令</p>
</li>
<li>
<p>串传送指令</p>
<ul>
<li>
<p>串传送指令MOVS</p>
<ul>
<li>
<p>将数据段中的字节或子数据传送至ES指向的段</p>
</li>
<li>
<p>movsb</p>
<ul>
<li>字节串传送</li>
<li>将ds:[si]赋给es:[di],并且移动si和di一字节</li>
</ul>
</li>
<li>
<p>movsw</p>
<ul>
<li>字串传送</li>
<li>将ds:[si]赋给es:[di],并且移动si和di两字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>串存储指令STOS</p>
<ul>
<li>
<p>将AL或AX的内容存入ES指向的段</p>
</li>
<li>
<p>stosb</p>
<ul>
<li>将al给 es:[di],然后di移动一字节</li>
</ul>
</li>
<li>
<p>stosw</p>
<ul>
<li>将ax给 es:[di],然后di移动两字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>串读取指令LODS</p>
<ul>
<li>
<p>将数据段中的数据传给AL或AX</p>
</li>
<li>
<p>lodsb</p>
<ul>
<li>将ds:[si]给al，然后si移动一字节</li>
</ul>
</li>
<li>
<p>lodsw</p>
<ul>
<li>将ds:[si]给ax，然后si移动一字节</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重复前缀指令REP</p>
<ul>
<li>重复cx次指令</li>
</ul>
</li>
<li>
<p>书写串名方式</p>
<ul>
<li>movs 目的串名,源串名</li>
</ul>
</li>
<li>
<p>使用方法</p>
<ul>
<li>在使用MOVS之前，要提前设置好DS，ES，SI，DI和方向标志DF，并将CX设置成重复的次数</li>
<li>通常DF设置为0，为地址增加方式</li>
</ul>
</li>
</ul>
</li>
<li>
<p>串检测指令</p>
<ul>
<li>
<p>串比较指令CMPS</p>
<ul>
<li>
<p>cmpsb</p>
<ul>
<li>将DS:[SI] - ES:[DI],然后移动si和di一字节</li>
</ul>
</li>
<li>
<p>cmpsw</p>
</li>
</ul>
</li>
<li>
<p>串扫描指令</p>
<ul>
<li>
<p>scasb</p>
<ul>
<li>将al-ES:[DI],移动di一字节</li>
</ul>
</li>
<li>
<p>scasw</p>
</li>
</ul>
</li>
<li>
<p>重复且判断前缀指令REPE</p>
<ul>
<li>
<p>repe|repz</p>
<ul>
<li>CX等于零或ZF等于一停止比较</li>
</ul>
</li>
</ul>
</li>
<li>
<p>重复且判断前缀指令REPNE</p>
<ul>
<li>
<p>repne|repnz</p>
<ul>
<li>CX等于零</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="子程序设计">子程序设计</h3>
<ul>
<li>
<p>过程定义伪指令</p>
<ul>
<li>
<p>子程序</p>
<ul>
<li>具有唯一子程序名的程序段</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li>子程序名 proc[near/far]<br>
过程体<br>
子程序名 endp</li>
</ul>
</li>
<li>
<p>属性</p>
<ul>
<li>
<p>near</p>
<ul>
<li>只能被相同代码段的其他程序调用</li>
</ul>
</li>
<li>
<p>far</p>
<ul>
<li>可以被不同代码段的程序调用</li>
</ul>
</li>
</ul>
</li>
<li>
<p>调用</p>
<ul>
<li>
<p>call 子程序名</p>
<ul>
<li>将返回地址压入栈</li>
</ul>
</li>
</ul>
</li>
<li>
<p>返回</p>
<ul>
<li>
<p>ret</p>
<ul>
<li>从当前栈顶取内容作为返回地址</li>
<li>注意执行ret之前要把子程序过程中压入的数据清空</li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意</p>
<ul>
<li>
<p>过程设计要注意寄存器的保护和恢复</p>
</li>
<li>
<p>方式</p>
<ul>
<li>程序开始压栈，程序结束弹栈</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序的参数传递</p>
<ul>
<li>
<p>用寄存器传递参数</p>
<ul>
<li>
<p>传递少量参数</p>
<ul>
<li>将数据保存在寄存器，并且不进行寄存器恢复</li>
</ul>
</li>
<li>
<p>传递大量参数</p>
<ul>
<li>将参数保存在连续的存储地址中，寄存器将该连续地址的首地址进行保存</li>
</ul>
</li>
</ul>
</li>
<li>
<p>用变量传递参数</p>
<ul>
<li>等效于用全局变量传参，通用性较差</li>
</ul>
</li>
<li>
<p>用堆栈传递参数</p>
<ul>
<li>
<p>现将传入的参数压入栈</p>
</li>
<li>
<p>将bp压入栈</p>
<ul>
<li>保护寄存器</li>
</ul>
</li>
<li>
<p>将bp指向栈顶sp</p>
<ul>
<li>mov bp, sp</li>
</ul>
</li>
<li>
<p>将要用的寄存器压入栈</p>
</li>
<li>
<p>使用压入的参数</p>
<ul>
<li>[bp+4 + 2i]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>子程序的嵌套递归和重入</p>
</li>
</ul>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://moyihust.github.io/post/dai-ma-sui-xiang-lu-day10/">
                  <h3 class="post-title">
                    代码随想录day10
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
